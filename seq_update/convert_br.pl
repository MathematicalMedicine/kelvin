#!/usr/bin/perl -w
use strict;

#
# convert_br - Convert Bayes Ratio (or avghet.out) files generated by previous
#              versions of Kelvin to the most recent format.
#
# John Burian - john.burian@nationwidechildrens.org
#
# Copyright 2008, The Research Institute at Nationwide Children's Hospital
# All rights reserved. Permission is granted to use this software for
# non-profit educational purposes only.
#

my $line;
my $lineno = 1;
my $version;
my $current = "0.36.1";
my ($maj, $min, $patch);
my $br_file = undef;
my @flds;
my @arr;
my $va;

my $force_chr = '';
# These are all used when a map file is necessary to insert a position 
# column in the converted file.
my $map_file = '';
my $map_fmt = undef;
my ($mrk_idx, $pos_idx);
my $pos_value;
my %marker_pos = ();

# How many markers in a multipoint file
my $markerlist_len = 0;
# Penetrance vector format: DT, QT w/ std dist, or QT w/ Chi**2 dist
my $penvector_type = '';
my $liability_classes = 1;

# These globals are set in the unkown version header parser, and used
# to determine the penetrance vector type, the number of liability 
# classes and the number of markers
my $markerlist_col = -1;
my $penvector_col = -1;

# These will be filled in by the appropriate header parsing routine
my $header = '';
my $data_regex = '';
my $data_fmt = '';
my @fld_idxs = ();
# Controls whether the value for the position column should be appended
# to the array of fields after a data line is parsed.
my $append_pos = 0;

my %header_parsers = ( "unknown" => \&pre_0_35_0,
		       "0.35.0" => \&ver_0_35_0,
		       "0.36.0" => \&ver_0_35_0,
		       "0.36.1" => \&ver_0_36_1 );

my $usage = "usage: $0 [-c <chr_num>] [-m <map_file>] <filename>\n";

while (scalar (@ARGV)) {
    if ($ARGV[0] =~ /-c(\d+)?/) {
        shift (@ARGV);
	$force_chr = (defined ($1)) ? $1 : shift (@ARGV);
        (defined ($force_chr) && ($force_chr =~ /^\d+$/)) or die ($usage);
    } elsif ($ARGV[0] =~ /-m(\S+)?/) {
        shift (@ARGV);
	$map_file = (defined ($1)) ? $1 : shift (@ARGV);
        (defined ($map_file)) or die ($usage);
    } elsif ($ARGV[0] =~ /(\?|help)/) {
        system ("/usr/bin/pod2text $0");
        exit (0);
    } else {
	defined ($br_file) and die ($usage);
	$br_file = shift (@ARGV);
    }
}

if (($map_file) && ($map_file ne 'nomap')) {
    open (FH, $map_file) or die ("$0: map file '$map_file': $!\n");
    while (! defined ($map_fmt)) {
	(defined ($line = <FH>)) or die ("$0: unknown map format in '$map_file'\n");
	if ($line =~ /\s*CHR(OMOSOME)?\s+(HALDANE|KOSAMBI|POSITION)\s+(NAME|MARKER)/i) {
	    $map_fmt = '\d+\s+([\-\d\.]+(?:e[\-\+]\d+)?)\s+(\S+)';
	    ($mrk_idx, $pos_idx) = (1, 0);
	} elsif ($line =~ /\s*CHR(OMOSOME)?\s+(NAME|MARKER)\s+(HALDANE|KOSAMBI|POSITION)/i) {
	    $map_fmt = '\d+\s+(\S+)\s+([\-\d\.]+(?:e[\-\+]\d+)?)';
	    ($mrk_idx, $pos_idx) = (0, 1);
	} elsif ($line =~ /\d+\s+([\-\d\.]+(?:e[\-\+]\d+)?)\s+(\S+)/) {
	    $marker_pos{$2} = $1;
	    $map_fmt = '\d+\s+([\-\d\.]+(?:e[\-\+]\d+)?)\s+(\S+)';
	    ($mrk_idx, $pos_idx) = (1, 0);
	} elsif ($line =~ /\d+\s+(\S+)\s+([\-\d\.]+(?:e[\-\+]\d+)?)/) {
	    $marker_pos{$1} = $2;
	    $map_fmt = '\d+\s+(\S+)\s+([\-\d\.]+(?:e[\-\+]\d+)?)';
	    ($mrk_idx, $pos_idx) = (0, 1);
	}
    }
    while ($line = <FH>) {
	unless (@arr = ($line =~ /$map_fmt/)) {
	    chomp ($line);
	    die ("$0: badly formatted line in '$map_file': '$line'\n");
	}
	$marker_pos{$arr[$mrk_idx]} = $arr[$pos_idx];
    }
    close (FH);
}

open (FH, $br_file) or die ("open '$br_file' failed, $!\n");
(defined ($line = <FH>)) or die ("$0: empty input file\n");

# Version information line, only appears in 0.35.0 and later
# All files with no Version line are treated as 'unknown'
if (($version) = ($line =~ /\#\s+Version\s+(\S+)/)) {
    (($maj, $min, $patch) = ($version =~ /(\d+)\.(\d+)\.(\d+)/))
	or die ("$0: badly formed version number '$version' at line $lineno\n");
    $version = sprintf ("%d.%d.%d", $maj, $min, $patch);
    $lineno++;
    (defined ($line = <FH>))
	or die ("$0: input file ends unexpectedly at line $lineno\n");
} else {
    $version = 'unknown';
}
(versionnum ($version) >= versionnum ($current)) 
    and die ("input file is already in most recent format ($current)\n");
exists ($header_parsers{$version})
    or die ("$0: don't know how to parse headers for version '$version'\n");
(($version eq 'unknown') && (length ($force_chr) <= 0))
    and die ("$0: -c <chr_num> is required for this file\n");

if ($version eq 'unknown') {
    # We have to build a general $data_regex and try to match one data line,
    # then count fields in PenetranceVector and MarkerList to figure out the
    # penetrance vector type, number of liability classes and how the converted
    # header line should look like.

    # If a 2-point marker info line, skip it
    if ($line =~ /^\#/) {
	(defined ($line = <FH>))
	    or die ("$0: input file ends unexpectedly at line $lineno\n");
	$lineno++;
    }
    &{$header_parsers{$version}} ($line);

    (defined ($line = <FH>))
	or die ("$0: input file ends unexpectedly at line $lineno\n");
    $lineno++;
    $line =~ s/\s+/ /g;
    $line =~ s/, +/,/g;
    (@flds) = ($line =~ /^\s*$data_regex\s*$/)
	or die ("$0: badly formed data line at line $lineno\n");
    ($markerlist_col != -1)
	and $markerlist_len = scalar (@arr = split (/,/, $flds[$markerlist_col]));
    $va = scalar (@arr = split (/ /, $flds[$penvector_col]));
    if (($va == 3) || ($va == 6) || ($va == 9)) {
	$penvector_type = "DT";
	$liability_classes = $va / 3;
    } elsif (($va == 4) || ($va == 8)) {
	$penvector_type = "QT_Chi";
	$liability_classes = $va / 4;
    } elsif (($va == 7) || ($va == 14)) {
	$penvector_type = "QT_T";
	$liability_classes = $va / 7;
    } else {
	die ("$0: can't determine penetrance vector type at line $lineno\n");
    }

    # Reset $header to an empty string, which will force the first header line
    # to be re-parsed, informed by $penvector_type, etc.
    $header = '';
    # And rewind the file to the beginning. We ignore the possibility of a 
    # version line, because we wouldn't be here if there had been one.
    seek (FH, 0, 0);
    $line = <FH>;
    $lineno = 1;

} elsif (versionnum ($version) < versionnum ("0.36.1")) {
    # Versioned 2-point BR files less than V0.36.1 have no position column.
    # If we find a marker information line (which only appears in 2-point
    # files), then set $append_pos.

    if ($line =~ /^\#/) {
	($map_file) or die ("$0: can't convert without a map file (use -m <map_file>)\n");
	$append_pos = 1;
    }
}

print ("# Version V$current (converted from ". (($version eq "unknown") ? "" : "V"). "$version)\n");
while (1) {

    if ($line =~ /^\#/) {
	# 2-Point marker info line
	($append_pos) and $pos_value = lookup_pos ($line);
	print ($line);

    } elsif ($line !~ /^[\-\+\d\.\s\(\,\)e]+$/) {
	# Column header line
	(length ($header) <= 0)
	    and &{$header_parsers{$version}} ($line);
	print ($header);

    } else {
	# By elimination, a data line
	(length ($data_regex) > 0)
	    or die ("$0: data line found before any header lines at line $lineno\n");
	$line =~ s/\s+/ /g;
	$line =~ s/, +/,/g;

	(@flds) = ($line =~ /^\s*$data_regex\s*$/)
	    or die ("$0: badly formed data line at line $lineno\n");
	($append_pos) and push (@flds, $pos_value);
	printf ($data_fmt, @flds[@fld_idxs]);
    }
    
    (defined ($line = <FH>)) or last;
    $lineno++;
}


sub pre_0_35_0 {
    my ($line) = @_;
    my @names;
    my @dprimes = ();
    my %mapped = ();
    my $str;
    my $va = 0;
    my $lc;

    $header = 'Chr ';
    $data_fmt = "$force_chr ";
    $data_regex = '';
    @fld_idxs = ();
    # Trim leading and trailing whitespace
    $line =~ s/^\s*(\S|\S.*\S)\s*$/$1/;
    # Remove spaces following commas
    $line =~ s/, +/,/;
    # And split on whitespace
    @names = split (/\s+/, $line);

    while ($str = shift (@names)) {
	$str = uc ($str);
	if ($str =~ /^D\d\d/) {
	    push (@dprimes, $str);
	    $mapped{$str}{idx} = [ $va ];
	    $mapped{$str}{fmt} = '%.2f ';
	    $data_regex .= '([\-\d\.]+) ';

	} elsif ($str eq "DPRIME") {
	    push (@dprimes, "D11");
	    (exists ($mapped{"D11"}))
		and die ("$0: multiple 'DPrime' columns in header at line $lineno\n");
	    $mapped{D11}{idx} = [ $va ];
	    $mapped{D11}{fmt} = '%.2f ';
	    $data_regex .= '([\-\d\.]+) ';

	} elsif ($str eq "THETA(M,F)") {
	    $mapped{"Theta(M,F)"}{idx} = [ $va ];
	    $mapped{"Theta(M,F)"}{fmt} = '%s ';
	    $data_regex .= '(\([\d\.]+,[\d\.]+\)) ';
	    
	} elsif ($str eq "COUNT") {
	    $data_regex .= '(\d+) ';

	} elsif ($str =~ /^(AVG_?LR|BR)$/) {
	    $mapped{"BayesRatio"}{idx} = [ $va ];
	    $mapped{"BayesRatio"}{fmt} = '%e ';
	    $data_regex .= '([\-\d\.]+(?:[eE][\+\-]\d+)?) ';

	} elsif ($str eq "AVGLR(COUNT)") {
	    $mapped{"BayesRatio"}{idx} = [ $va ];
	    $mapped{"BayesRatio"}{fmt} = '%s ';
	    $data_regex .= '([\-\d\.]+(?:[eE][\+\-]\d+)?)\(\d+\) ';

	} elsif (($str eq "MAX_HLOD") || ($str eq "MOD")) {
	    $mapped{"MOD"}{idx} =  [$va ];
	    $mapped{"MOD"}{fmt} = '%.4f ';
	    $data_regex .= '([\-\d\.]+) ';

	} elsif ($str eq "R2") {
	    $mapped{"R2"}{idx} = [ $va ];
	    $mapped{"R2"}{fmt} = '%.4f ';
	    $data_regex .= '([\-\d\.]+) ';

	} elsif ($str eq "ALPHA") {
	    $mapped{"Alpha"}{idx} = [ $va ];
	    $mapped{"Alpha"}{fmt} = '%.2f ';
	    $data_regex .= '([\d\.]+) ';

	} elsif ($str eq "DGF") {
	    $mapped{"DGF"}{idx} = [ $va ];
	    $mapped{"DGF"}{fmt} = '%.4f ';
	    $data_regex .= '([\d\.]+) ';

	} elsif ($str eq "MF") {
	    $mapped{"MF"}{idx} = [ $va ];
	    $mapped{"MF"}{fmt} = '%.4f ';
	    $data_regex .= '([\d\.]+) ';

	} elsif (($str eq "PEN_VECTOR") || ($str eq "PEN_DD")) {
	    if ($str eq "PEN_DD") {
		(($names[0] =~ /PEN_DD/i) && ($names[1] =~ /PEN_DD/i))
		    or die ("$0: one or more penetrance headers missing at line $lineno\n");
		splice (@names, 0, 2);
	    }
	    $mapped{"PenetranceVector"}{idx} = [ ];
	    $mapped{"PenetranceVector"}{fmt} = '';
	    if ($penvector_type eq "") {
		push (@{$mapped{"PenetranceVector"}{idx}}, $va);
		$mapped{"PenetranceVector"}{fmt} .= '%s ';
		$penvector_col = $va;
		$data_regex .= '([\-\d\.]+(?: [\-\d\.]+)+) ';
	    } elsif ($penvector_type eq "DT") {
		for ($lc = 0; $lc < $liability_classes; $lc++) {
		    push (@{$mapped{"PenetranceVector"}{idx}}, $va, $va+1, $va+2);
		    $mapped{"PenetranceVector"}{fmt} .= '(%s,%s,%s) ';
		    $data_regex .= '([\-\d\.]+) ' x 3;
		    $va += 3;
		}
		$va--;
	    } elsif ($penvector_type eq "QT_Chi") {
		for ($lc = 0; $lc < $liability_classes; $lc++) {
		    push (@{$mapped{"PenetranceVector"}{idx}}, $va, $va+1, $va+2, $va+3);
		    $mapped{"PenetranceVector"}{fmt} .= '(%s,%s,%s,%s) ';
		    $data_regex .= '([\-\d\.]+) ' x 4;
		    $va += 4;
		}
		$va--;
	    } elsif ($penvector_type eq "QT_T") {
		for ($lc = 0; $lc < $liability_classes; $lc++) {
		    push (@{$mapped{"PenetranceVector"}{idx}}, $va, $va+1, $va+2, $va+3,
			  $va+4, $va+5, $va+6);
		    $mapped{"PenetranceVector"}{fmt} .= '(%s,%s,%s,%s,%s,%s,%s) ';
		    $data_regex .= '([\-\d\.]+) ' x 7;
		    $va += 7;
		}
		$va--;
	    }
	    
	} elsif ($str =~ /^POS(ITION)?/) {
	    $mapped{"Position"}{idx} = [ $va ];
	    $mapped{"Position"}{fmt} = '%.4f ';
	    $data_regex .= '([\d\.]+) ';
	    
	} elsif ($str eq "PPL") {
	    $mapped{"PPL"}{idx} = [ $va ];
	    $mapped{"PPL"}{fmt} = '%s ';
	    $data_regex .= '([\d\.]+) ';
	    
	} elsif ($str eq "MARKERLIST") {
	    $mapped{"MarkerList"}{idx} = [ $va ];
	    $mapped{"MarkerList"}{fmt} = '%s ';
	    if ($markerlist_len == 0) {
		$markerlist_col = $va;
	    } 
	    $data_regex .= '(\([\d\,]+\)) ';
	    
	} else {
	    die ("$0: unknown header '$str' at line $lineno\n");
	}
	$va++;
    }

    if (! exists ($mapped{Position})) {
	($map_file) or die ("$0: can't convert without a map file (use -m <map_file>)\n");
	$header .= "Position ";
	push (@fld_idxs, $va);
	$data_fmt .= "%s ";
	$append_pos = 1;
    }
    foreach $str (@dprimes) {
	$header .= "$str ";
	push (@fld_idxs, @{$mapped{$str}{idx}});
	$data_fmt .= $mapped{$str}{fmt};
    }
    foreach $str ('Theta(M,F)', qw/Position PPL BayesRatio MOD R2 Alpha
		  DGF MF PenetranceVector MarkerList/) {
	defined ($mapped{$str}) or next;
	if ($str eq "PenetranceVector") {
	    if ($penvector_type eq "") {
		$header .= "$str ";
	    } elsif ($penvector_type eq "DT") {
		for ($lc = 0; $lc < $liability_classes; $lc++) {
		    $header .= "LC${lc}PV(DD,Dd,dd) ";
		}
	    } elsif ($penvector_type eq "QT_Chi") {
		for ($lc = 0; $lc < $liability_classes; $lc++) {
		    $header .= "LC${lc}PV(DDMean,DdMean,ddMean,Thresh) ";
		}
	    } elsif ($penvector_type eq "QT_T") {
		for ($lc = 0; $lc < $liability_classes; $lc++) {
		    $header .= "LC${lc}PV(DDMean,DdMean,ddMean,DDSD,DdSD,ddSD,Thresh) ";
		}
	    }
	} elsif ($str eq "MarkerList") {
	    $header .= "MarkerList(". join (',', (0 .. ($markerlist_len - 1))) . ") ";
	} else {
	    $header .= "$str ";
	}
	push (@fld_idxs, @{$mapped{$str}{idx}});
	$data_fmt .= $mapped{$str}{fmt};
    }
    
    chop ($data_regex, $data_fmt, $header);
    $header .= "\n";
    $data_fmt .= "\n";
    return;
}


# V0.35.0 -> V0.36.1 : Add a position column to two-point files
sub ver_0_35_0
{
    my ($line) = @_;

    if ($line =~ /Position/) {
	#   If there's already a Position column (there will be in multi-point files),
	#   then we do nothing
	$append_pos = 0;
	$header = $line;
	$data_regex = '(\S.*\S)';
	$data_fmt = "%s\n";
	@fld_idxs = (0);
    } else {
	#   Otherwise, splice in a Position column just after the Chr column
	#   This next bit should be redundant with the first-line logic, above
	$append_pos = 1;
	($header = $line) =~ s/(Chr)\s+(\S.*)/$1 Position $2/;
	$data_regex = '(\d+)\s+(\S.*)';
	$data_fmt = "%s %s %s\n";
	@fld_idxs = (0, 2, 1);
    }
    return;
}


# A stub that should never be called
sub ver_0_36_1
{
    ;
}


sub versionnum 
{
    my ($str) = @_;
    my ($maj, $min, $patch);

    (($maj, $min, $patch) = ($str =~ /(\d+)\.(\d+)\.(\d+)/))
	or return (0);
    return ($maj * 100000 + $min * 1000 + $patch);
}


sub lookup_pos
{
    my ($line) = @_;
    my ($num, $name1, $name2);

    unless (($num, $name1, $name2) = ($line =~ /\#\s+(\d+)\s+(\S+)\s+(\S+)/)) {
	chomp ($line);
	die ("$0: badly formatted marker info at line $lineno\n");
    }
    ($map_file eq 'nomap') and return ($num);
    exists ($marker_pos{$name1}) and return ($marker_pos{$name1});
    exists ($marker_pos{$name2}) and return ($marker_pos{$name2});
    die ("$0: can't find position based on marker info at line $lineno\n");
}


=head1 USAGE

convert_br.pl [-c <chr_num>] [-m <map_file>] infile

Converts Bayes ratio (br.out) or average heterogeneity (avghet.out) files
generated by older version of Kelvin the most recent br.out format.

=head1 COMMAND LINE ARGUMENTS

=item -c <chr_num>

=over 3

Specifies the chromosome number. Required if the input file does not contain
a chromosome number column, and optional otherwise. If specified, and the input
file already contains a chromosome column, the chromosome number in the output
will be forced to <chrnum>.

=back

=item -m <map_file>

=over 3

Specifies a map file that lists centiMorgan positions of markers. Required if
the input file contains two-point Bayes ratios and does not contain a marker
position column, and ignored otherwise. If map_file is specified as the literal
string 'nomap', the marker positions in the output will be filled with the
sequential marker number.

=back

=cut
