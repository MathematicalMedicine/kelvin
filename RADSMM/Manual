Random Access Data Storage for MLip Multiple Model (RADSMM)

 These routines provide a method of storing and accessing 
the data generated by mlip program using random access.
 The file contains a header that stores the complete information 
about the parameters used to generate data.
  Note that multiple file support will not be included in the first versions

All RADSML routine return a status of type int. less than 0 values indicate 
error. 0=successful. some routines return informationally values that are >0.
If debug_level (see RADSML_init ) has bits 1  or 2 set, then errors will 
cause an error message to be written to stdout, this error message
will often contain more information than the error code.

 This version supports multiple data models. The Currently 3 flags control 
models supported. They are Point_Type (2 for 2 point, M for Multipoint),
Model type ( 'D'icotomous or  'Q'uanitative Traits) and a Disequalibrium. 
All models share the Pedigree parameter.
Unique parameters are...
 Dicotomous uses Penetrance and GeneFreq, Quanitative Traits uses a model number. 
 2 points uses a marker and a theta (grid or diagonal) while multipoint uses Marker
 to store the loci number.
 Disequalibrium: Add a Lamba parameter.
 
The header is defined in RADSMM.h and the calling program must declare it and
pass it to all routines. It is possible to work with multiple data sets by
declaring multiple headers.

Some routinues should be called before others. Mainly RADSMM_open_file or
RADSMM_create_file must be called before RADSMM_read_data or RADSMM_write_data.

####################Routines to Create Files##################################
# These routines are only useful before a calling RADSMM_create_file         #
# Calling these routines after opening or creating a file will cause an error#
# It is recommended that you call RADSMM_setup_init first.		     #
##############################################################################

-----------------------------------------------------------------------------
int RADSMM_setup_type( RADSMM_header_type *header, char Point_Type, char model_type, char use_diseq );


The Point_type must be '2' for 2 point or 'M' for multipoint.  (Default '2')
The model_type must be 'D' for dichotomous, 'Q' for Quanitative Traits or  (Default 'D')
The Use_Diseq must be 'N' for no, or 'Y' if the lamba parameter is present  (Default 'N')

Defaults are set in RADSMM_setup_init.
It is strongly recommended that this routine be called and not left to default.

Will return RADSMM_ERROR_badparam if not correct.

-----------------------------------------------------------------------------
int RADSMM_setup_LC( RADSMM_header_type *header, int number_of_LC );

 In RADSMM_setup_init this is set to 1, Override that with a call to this routine.
You must call this routine before setup_pedigree

Will return RADSMM_ERROR_badparam if pedigree_count is out of range.
Will return RADSMM_ERROR_malloc if an error occurs during malloc.


-----------------------------------------------------------------------------
int RADSMM_setup_pedigree( RADSMM_header_type *header, int pedigree_list[], 
					long pedigree_count );
  The pedigree list may be NULL. In this case the the ped list is assumed to be
sequential from 0 upto (and not including) pedigree_count.

Will return RADSMM_ERROR_badparam if pedigree_count is out of range.
Will return RADSMM_ERROR_malloc if an error occurs during malloc.

-----------------------------------------------------------------------------
int RADSMM_setup_theta( RADSMM_header_type *header, double theta_list[], 
			long theta_count, char theta_matrix_type );
theta_matrix_type can be either 'D' for diagonal or 'G' for grid

Will return RADSMM_ERROR_badparam if theta_count is out of range.
Will return RADSMM_ERROR_malloc if an error occurs during malloc.

-----------------------------------------------------------------------------
int RADSMM_setup_penetrance( RADSMM_header_type *header, int LC_index
                        float penetrance_list1[], float penetrance_list2[], 
			float penetrance_list3[], long penetrance_count );

Pass 3 arrays, each must have at least penetrance_count elements. Such that
pentrance combination I equal
(penetrance_list1[I],penetrance_list2[I],penetrance_list3[I])

Will return RADSMM_ERROR_wrong_model if model_type is not set to Dichotomous
              or Disequalbrum.
Will return RADSMM_ERROR_badparam if penetrance_count is out of range.
Will return RADSMM_ERROR_malloc if an error occurs during malloc.

-----------------------------------------------------------------------------
int RADSMM_setup_qmodel( RADSMM_header_type *header, long model_count );

Set the number of different models that will be used. Vaild Model_indexs
range from 0 to 1-model_count

Will return RADSMQ_ERROR_badparam if model_count is out of range.
Will return RADSMQ_ERROR_malloc if an error occurs during malloc.

-----------------------------------------------------------------------------  
int RADSMM_setup_geneFreq( RADSMM_header_type *header, double genefreq[], 
							long genefreq_count );
  Stores the gene freq 

Will return RADSMM_ERROR_badparam if count is out of range.
Will return RADSMM_ERROR_malloc if an error occurs during malloc.


-----------------------------------------------------------------------------  
int RADSMM_setup_lambda( RADSMM_header_type *header, double lambdalist[], 
							long lambda_count );
  Stores the gene lambda values. 

Will return RADSMM_ERROR_badparam if count is out of range.
Will return RADSMM_ERROR_badparam if count is out of range.
Will return RADSMM_ERROR_malloc if an error occurs during malloc.


......NOTE.....
  RADSMM_setup_* routines basically fill the header data structure. 
These all allocate memory for the the arrays. Count is check to be >0 <max 
defined in RADSMM.h. Arrays are not checked to see that they are in 
ascending order (not required now, maybe in future for speedup.)

-----------------------------------------------------------------------------
int RADSMM_setup_data( RADSMM_header_type *header, int number_of_markers, 
					char data_type, int checksum_type );
  number_of_markers is the number of markers that will write/read at a time.
  data_type can be 'D'|'d' for double (8bytes) or 'F'|'f' for float (4bytes)
  checksum_type is currently not implimented and should be 0 (no checksum). 

Will return RADSMM_ERROR_badparam if marker_count is out of range or
  if data_type is not F|f|D|d of if checksum type is anything other than 0

-----------------------------------------------------------------------------
int RADSMM_setup_ordering( RADSMM_header_type *header, char ordering ); 

   This controls the how the data is ordered when stored in the datafile.
The following orderings are available, where the first item is the most significant
(i.e. changing will result in a large jump in file position) and the last item
is least significant (i.e. incriment means incriment the file position by one)
Note that parameters that are not used are ignored.

 A: Pedigree, Marker, MaleTheta, FemaleTheta, GeneFreq, Penetrance, Lambda, Qmodel  
 B: Pedigree, GeneFreq, Penetrance, Qmodel, Male Theta, Female Theta, Lambda, Marker
 C: Marker, Pedigree, Qmodel, MaleTheta, FemaleTheta, GeneFreq, Penetrance
 D: Pedigree, MaleTheta, FemaleTheta, Marker, Genefreq, Penetrance
 E: Pedigree, GeneFreq, Penetrance, Marker, Male Theta, Female Theta
 F: Marker, Penetrance, Qmodel, Male Theta, Female Theta, lambda, Pedigree

Note that accessing the file sequentially can be an order of magnitude faster 
than accessing randomly. 

 RADSMM_setup_init will set the ordering to 'B'.(i.e. the default)
(Version 1 of RADSML used A).
If you want a different ordering you can call with routine before RADSMM_create_file.

Will return RADSMM_ERROR_badparam if ordering is not in the above list.


-----------------------------------------------------------------------------
int RADSMM_setup_markerlabel( RADSMM_header_type *header, int label_length );

    This routine sets the parameters for markerlabels. Label_length is the 
fixed length size for each label. RADSMM_setup_data must be called first 
so the number of markers is known.  The markerlabels are initialized with
strings like 'Marker1' or 'M1' depending on the label_length. If this routine
is not called (or called with label_length = 0), nothing will be stored. 

returns RADSMM_ERROR_badparam if label_length out of range.
returns RADSMM_ERROR_malloc if malloc returns an error.

-----------------------------------------------------------------------------
int RADSMM_set_markerlabel( RADSMM_header_type *header, int markerindex, 
			    char *label );

    This routine should be once for each marker label. It stores the 
markerlabels so they may be put in the header. Markerindex indicates which 
marker is to be assocated with the sent string and should be between
0 and number of markers -1. The label string will be terminated 
either at the length set by label_length in RADSMM_setup_markerlabel or when 
a null (\0) is seen, whichever first. No checking is done to see if string 
truncation occurs.

returns RADSMM_ERROR_badparam if mountindex out of range.

-----------------------------------------------------------------------------
int RADSMM_setup_pedigreelabel( RADSMM_header_type *header, int label_length );
    This routine sets the parameters for Pedigree labels. Label_length is the 
fixed length size for each label. RADSMM_setup_pedigree must be called first 
so the number of pedigree is known.  The pedigree labels are initialized with
strings like 'Pedigree 1' or 'P1' depending on the label_length.

returns RADSMM_ERROR_badparam if label_length out of range.
returns RADSMM_ERROR_malloc if malloc returns an error.

-----------------------------------------------------------------------------
int RADSMM_set_pedigreelabel( RADSMM_header_type *header, int pedigreeindex, 
			    char *label );
    This routine should be once for each pedigree label. It stores the 
pedigree labels so they may be put in the header. The string will be terminated 
either at the length set by label_length in RADSMM_setup_markerlabel or when 
a null (\0) is seen, whichever first. No checking is done to see if string 
truncation occurs.

returns RADSMM_ERROR_badparam if mountindex out of range.

-----------------------------------------------------------------------------
int RADSMM_setup_comments( RADSMM_header_type *header, char *comment );

  This routine will put a comment in the header which will be written to 
the file. The maximum length of the comment string is 64 characters. 
It also puts the current date/time in file as well, so it should be called 
even if you  don't have a comment.

Always returns 0;

-----------------------------------------------------------------------------
int RADSMM_file_size( RADSMM_header_type *header, double *size, 
		      int *number_of_files )
  This routine calculates size to be the size of the file (first file 
containing header) that will be created. (-1 if too big ) Currently 
number_of_files will always be set to 1. Will return 0 if size is OK, 
otherwise returns RADSMM_ERROR_badparam. It is not necessary to call this 
routine, it gives you chance check this before calling RADSMM_create_file 
which will fail if the file is too big.

 Returns RADSMM_ERROR_badparam if theta matrix is not D|G or if calculated
size if < 0 

-----------------------------------------------------------------------------
int RADSMM_create_file( RADSMM_header_type *header,  char* filename, int mode );

   mode is the access permissions ie 0600 gives owner read+write, it will 
be (or)ed with !umask (see chmod)
   Calls RADSMM_file_size and Immeadately fails if file is too big.
   Filename is checked for existance and an error is returned if it already 
exists. (i.e. will not overwrite an existing file of any type.)
   Checks are made against the headerinfo (less the max sizes, proper
values, values are in order, etc.etc.) and errors.
    File is then created, lockf, header written, indexs are written and all the 
spaces are  filled with the predefine constant RADSMM_EMPTY
   Leaves with the same state as if RADSMM_open_file was called with an 
already created file.
   Note that depending on system configuratation and file size, this routine
may take several seconds (if not minutes) to finish because it has to write
"EMPTYS" into the entire file(s).

Returns RADSMM_ERROR_already_open if file is already open.

Returns RADSMM_ERROR_badparam if any of the following is true.
    marker_count is out of range.
    data_type is not 'F'|'D'
    pedigree_count is out of range
    theta_count is out of range
    Penetrance|traits_count is out of range
    geneFreq_count is out of range
Returns RADSMM_ERROR_fileopen is call to open fails.
Returns RADSMM_ERROR_locking is call to lockf fails.
Returns RADSMM_ERROR_writing if any of several write calls fail.
Returns RADSMM_ERROR_lseek if any of several lseek calls fail.


##################Other File wide routines##################################


int RADSMM_setup_init( RADSMM_header_type *header, debug_level );
  Strictly optional but recommened. Initializes all values in the header to
zero/not_used/undefined. Debug_level is a bit-mapped value of 0 to 255 where 
bit 1 toggles printing of error messages.
bit 2 toggles printing of informational messages.
bit 4 toggles printing of debug level 1 messages
bit 8 toggles printing of debug level 2 messages
bit 16 toggles printing of debug level 3 messages
bit 32 is not currently used.
bit 64 is not currently used.
bit 128 will cause a check that prevents data overwrites.

It is not recommended for a normal user to turn on the debug messages, 
especially level 2 and level 3 as they many cause excessive output and 
dramatically slow your code.

Bit 128, will cause RADSMM_write_data and RADSMM_write_float to read the
data before it is overwritten. See RADSMM_write_data and RADSMM_write_float 
for more details.

Always returns 0;

-----------------------------------------------------------------------------
int RADSMM_open_file( RADSMM_header_type *header,  char* filename, char mode);
    filename points to the file name. If mode is not 'W' or 'w' then the
file is opened readonly and not locked. Otherwise it is opened Read+Write 
and locked. Header & indexes is read, stored in header data  structure and 
returned.

Returns RADSMM_ERROR_already_open is file is already open.
Returns RADSMM_ERROR_fileopen if a call to open returns an error.
Returns RADSMM_ERROR_locking if call to lockf returns an error.
Returns RADSMM_ERROR_reading if one of several calls read returns an error.
Returns RADSMM_ERROR_file_header if one of the following happens...
  The cookie is not correct in the file header.
  The file version is not a support one.
  The number of extra fies is not in range.
  chunks_per_file is < 0
  Marker_count is out of range.
  data type is not 'F'|'D'
  pedigree_count is out of range.
  theta_count is out of range.
  theta matrix type is not 'D'|'G'
  Penetrance|traits count is out of range
  geneFreq count is out of range
  markerlabel size is less than 0
  pedigreelabel size is less than 0
Returns RADSMM_ERROR_malloc if a call to malloc returns an error.  

-----------------------------------------------------------------------------
int RADSMM_close_file( RADSMM_header_type *header );
    File is unlockf, closed.

Returns RADSMM_ERROR_not_open if no file is open.

-----------------------------------------------------------------------------
int RADSMM_sync( RADSMM_header_type *header );
    This rouinte calls fsync for all open data files. You really don't need
to call it unless you are afraid the computer might crash and you want
your data saved. In future, if counters are added to header, may cause header
to be rewritten. 

Returns RADSMM_ERROR_writing if sync call fails.

###############Routines to read/write file#####################################
#  It is not necessary to call the index routines if you know the index       #
# values. Index values start at 0.					      #
###############################################################################

-----------------------------------------------------------------------------
long RADSMM_index_pedigree( RADSMM_header_type *header, int pedid );

 Also use for loci in Multipoint. Returns the location (0 offset) 
in the pedigree list set in RADSMM_setup_pedigree. 

Returns RADSMM_ERROR_value_not_in_list if pedid is not found in the list.

-----------------------------------------------------------------------------
long RADSMM_index_theta( RADSMM_header_type *header, double male_theta, 
			 double female_theta );

 Returns an index for use in RADSMM_read_data and RADSMM_write_data.
Returns RADSMM_ERROR_value_not_in_list if pedid not found in the list.
Returns RADSMM_ERROR_badparam if theta martix type is 'D' and male_theta
does not equal female_theta

-----------------------------------------------------------------------------
long RADSMM_index_Penetrance( RADSMM_header_type *header, float Penetrance1, 
			      float Penetrance2, float Penetrance3 );

 Returns the location (0 offset) in the Penetrance combination list set in 
RADSMM_setup_Penetrance. 

Returns RADSMM_ERROR_wrong_model if model_type is not Dichotomous.
Returns RADSMM_ERROR_value_not_in_list if the Penetrance combination is 
not found in the list.

-----------------------------------------------------------------------------

----------------------------------------------------------------
Note that there is no RADSMQ_index_Qmodel because it is assumed
the caller knows which model to use. 

-----------------------------------------------------------------------------
long RADSMM_index_lambda( RADSMM_header_type *header, double lambda, );

 Returns the location (0 offset) in the lamba list set in 
RADSMM_setup_lambdas. 

Returns RADSMM_ERROR_wrong_model if model_type is not _Traits.
Returns RADSMM_ERROR_value_not_in_list if the traits combination is not 
found in the list.

-----------------------------------------------------------------------------
long RADSMM_index_genefreq( RADSMM_header_type *header, double genefreq );

 Returns the location (0 offset) in the Gene Frequency list set in 
RADSMM_setup_pedigree. Returns RADSMM_ERROR_value_not_in_list if
genefreq is not found in the list.

----------------------------------------------------------------
Note that there is no RADSMM_index_marker because it is assumed 
the caller knows which markers are in use. RADSMM_index_markerlabel maybe
used inplace if the marker labels are unique and correct.

-----------------------------------------------------------------------------
int RADSMM_read_data( RADSMM_header_type *header, long ped_index, 
		      long marker_or_loci_index,long theta_index, long genefreq_index, 
		      long penet_index, long qmodel_index,  lambda_index, double *data )

Data is double and converted to/from the internal format (either float or 
double). Also note that reads should check data to see if 
it is valid data (i.e. not an error/informational code) This can be done 
by seeing if the value is less than RADSMM_not_data_limit.

For the Dicotomous model
   Model1_index should be a penetrance index and Model2_index is ignored.

For the Disequalibrium model
   Model1_index should be a penetrance index and Model2_index should be a
lambda index.

For the Quanitative Traits model
   Model1_index should be a means index and Model2_index should be a
variance index.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call to lseek returns an error;
Returns RADSMM_ERROR_reading if the call to read returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'

-----------------------------------------------------------------------------
int RADSMM_write_data( RADSMM_header_type *header, long ped_index, 
		      long marker_or_loci_index, long theta_index, long genefreq_index, 
		      long penet_index, long qmodel_index,  lambda_index, 
		      double *data )

Data is double and converted to the internal format (either float or double). 
Note that overwriting existing data will generate no error. Yes, you need
to pass data by reference in _write_data, why? just to be consistant.  

For the Dicotomous model
   Model1_index should be a penetrance index and Model2_index is ignored.

For the Disequalibrium model
   Model1_index should be a penetrance index and Model2_index should be a
lambda index.

For the Quanitative Traits model
   Model1_index should be a means index and Model2_index should be a
variance index.

If (debug & 128) then read before write is done. Only if the data readin is 
RADSMM_empty or RADSMM_ignored or same as new data to write will write occur,
otherwise RADSMM_ERROR_writeover_valid_data is returned and no write is done.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call is lseek returns an error;
Returns RADSMM_ERROR_writing if the call to write returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns RADSMM_ERROR_writeover_valid_data if debug bit 128 is set already contains
   valid different data at that point.
Returns RADSMM_ERROR_outofrange if file holds floats and data passed is out of range
   allowable for floats.


-----------------------------------------------------------------------------
int RADSMM_read_float( RADSMM_header_type *header, long ped_index, 
  		       long marker_or_loci_index, long theta_index, long genefreq_index, 
		       long penet_index, long qmodel_index,  lambda_index, 
		       float *data )

Data is float and converted to/from the internal format (either float or 
double). Also note that reads should check data to see if 
it is valid data (i.e. not an error/informational code) This can be done 
by seeing if the value is less than RADSMM_not_data_limit.

See RADSMM_read_data for an explanation of Model1_index and model2_index.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call to lseek returns an error;
Returns RADSMM_ERROR_reading if the call to read returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns RADSMM_ERROR_outofrange if file holds double and data read is out of range
   allowable for floats.


-----------------------------------------------------------------------------
int RADSMM_write_float( RADSMM_header_type *header, long ped_index, 
		        long marker_or_loci_index, long theta_index, long genefreq_index, 
		        long penet_index, long qmodel_index,  lambda_index, 
                        float *data )

Data is float and converted to the internal format (either float or double). 
Note that overwriting existing data will generate no error. Yes, you need
to pass data by reference in _write_data, why? just to be consistant.  

See RADSMM_read_data for an explanation of Model1_index and model2_index.

If (debug & 128) then read before write is done. Only if the data readin is 
RADSMM_empty or RADSMM_ignored or same as new data to write will write occur,
otherwise RADSMM_ERROR_writeover_valid_data is returned and no write is done.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call is lseek returns an error;
Returns RADSMM_ERROR_writing if the call to write returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns RADSMM_ERROR_writeover_valid_data if debug bit 128 is set already contains
   valid different data at that point.
Returns RADSMM_ERROR_outofrange if float holds float and data passed is out of range
   allowable for floats.

#########################Block Read/Write Routines############################
#
#

-----------------------------------------------------------------------------
int RADSMM_read_list_float( RADSMM_header_type *header, long ped_index, 
		            long marker_or_loci_index, long theta_index, long genefreq_index, 
		            long penet_index, long qmodel_index,  lambda_index, 
		            float *data, long ndxcnt )

Data is converted from doubles if internal format is double. Depending
on Ordering type, the Least Significant index plus ndxcnt must be less than 
or equal to the Max of that index. No overwriting checks. 

See RADSMM_read_data for an explanation of Model1_index and model2_index.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call to lseek returns an error;
Returns RADSMM_ERROR_reading if the call to read returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns RADSMM_ERROR_outofrange if file holds double and data read is out of range
   allowable for floats.
Returns RADSMM_ERROR_outofrange if ndxcnt plus apporiate index is larger than
max of that index.


-----------------------------------------------------------------------------
int RADSMM_read_list_double( RADSMM_header_type *header, long ped_index, 
  		             long marker_or_loci_index, long theta_index, long genefreq_index, 
		             long penet_index, long qmodel_index,  lambda_index, 
  			     float *data, long ndxcnt )

Data is converted from float if internal format is float. Depending
on Ordering type, the Least Significant index plus ndxcnt must be less than 
or equal to the Max of that index. No overwriting checks. 

See RADSMM_read_data for an explanation of Model1_index and model2_index.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call to lseek returns an error;
Returns RADSMM_ERROR_reading if the call to read returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns  RADSMM_ERROR_outofrange if ndxcnt plus apporiate index is larger than
max of that index.


-----------------------------------------------------------------------------
int RADSMM_write_list_float( RADSMM_header_type *header, long ped_index, 
		             long marker_or_loci_index, long theta_index, long genefreq_index, 
		             long penet_index, long qmodel_index,  lambda_index, 
			     float *data, long ndxcnt )

Data is converted to double if internal format is double. Depending
on Ordering type, the Least Significant index plus ndxcnt must be less than 
or equal to the Max of that index. No overwriting checks. 

See RADSMM_read_data for an explanation of Model1_index and model2_index.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call to lseek returns an error;
Returns RADSMM_ERROR_reading if the call to read returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns  RADSMM_ERROR_outofrange if ndxcnt plus apporiate index is larger than
max of that index.


-----------------------------------------------------------------------------
int RADSMM_write_list_double( RADSMM_header_type *header, long ped_index, 
		      long marker_or_loci_index, long theta_index, long genefreq_index, 
		      long penet_index, long qmodel_index,  lambda_index, 
long ped_index, 
		        long theta_index, long genefreq_index, 
			long marker_index, long model1_index, long model2_index,
			float *data, long ndxcnt )

Data is converted to float if internal format is float. Depending
on Ordering type, the Least Significant index plus ndxcnt must be less than 
or equal to the Max of that index. No overwriting checks. 

See RADSMM_read_data for an explanation of Model1_index and model2_index.

Returns RADSMM_ERROR_not_open is file is not open.
Returns RADSMM_ERROR_badparam is any index parameter is out of range
 (This check is only done if debug_level has bits 16 or 8 or 4 set)
Returns RADSMM_ERROR_badparam if the calculated offset is negative.
Returns RADSMM_ERROR_lseek if the call to lseek returns an error;
Returns RADSMM_ERROR_reading if the call to read returns an error;
Returns RADSMM_ERROR_badparam if the data type flag is not 'F'|'D'
Returns  RADSMM_ERROR_outofrange if ndxcnt plus apporiate index is larger than
max of that index.
Returns RADSMM_ERROR_outofrange if file holds floats and data read is out of range
   allowable for floats.


##########################Label Routines######################################
#  Also see setup routines RADSMM_setup_markerlabel, RADSMM_set_markerlabel, #
# RADSMM_setup_Pedigreelabel, RADSMM_set_Pedigreelabel                       #
##############################################################################

-----------------------------------------------------------------------------
char  *RADSMM_get_markerlabel( RADSMM_header_type *header, int marker_index );
   This routine provides the Marker Label associated with that marker index. 
All strings will be null terminated, even ones with length = label_length
An example:
for( i=0 ; i<number_of_markers ; i++ )
  printf(" %s:%f\n",RADSMM_get_markerlabel( &header, i), data[i] );

Returns "Error\0" if marker_index out of range or if there is an calloc error.

-----------------------------------------------------------------------------
char  *RADSMM_get_pedigreelabel( RADSMM_header_type *header, 
			         int pedigree_index );
   This routine provides the pedigree label associated with that marker index. 
All strings will be null terminated, even ones with length = label_length

Returns "Error\0" if pedigree_index out of range or if there is an calloc error.

-----------------------------------------------------------------------------
    **** Not Yet Implimented ****
long RADSMM_index_markerlabel( RADSMM_header_type *header, char *markerlabel );
   This routine is kinda optional. Pass it a marker label and it will return 
the index. Useful if know the label but not the index. Note: it is possible 
for markerlabels for different markers to be the same, in that case the index
of the first match is returned.  An Example:
printf( " Marker ATAG05B4 %F",data[RADSMM_index_marker( &hdr, "ATAGO5B4")] );
(Bad exmaple because if that label is not found, -1 is returned and !ERROR! )

-----------------------------------------------------------------------------
    **** Not Yet Implimented ****
long RADSMM_index_pedigreelabel( RADSMM_header_type *header, 
				 char *pedigreelabel );
   This routine is kinda optional. Pass it a pedigree label and it will return 
the index. Useful if know the label but not the index. Note: it is possible 
for pedigree labels for different pedigree to be the same, in that case the index
of the first match is returned.

####################################################################################
Other info...

 see RADSMM_file_header.h for file header information.
{ Normal developers don't need to know the file header }

Possible non data values for data elements.    These apply if float or double.
The final word is in RADSMM.h

RADSMM_EMPTY	  	 3.29E+38	 /* Initialized state */
RADSMM_IGNORED    	 3.28E+38/* Purposefully left blank */


RADSMM_Infinity		 3.40E+38
RADSMM_Negative_Infinity 3.39E38
RADSMM_Not_Possible	 3.38E38
RADSMM_Not_a_Nubmer	 3.37E38
RADSMM_not_data_limit	 3.20E38


