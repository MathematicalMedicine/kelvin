#!/usr/bin/perl -w
use strict;
use Data::Dumper;
use File::Basename;
# KelvinDataset will be required later
# KelvinConfig, ditto
# KelvinFamily, double ditto

# KELVIN frontend script 
# Copyright 2009, Nationwide Children's Hospital Research Institute
# All rights reserved. Permission is hereby granted to use this software
# for non-profit educational purposes only.

# These four variables are typically set during the 'make install'. If the
# values are still 'NO_<variable_name>', then the script you are reading
# was not formally installed. Never fear, we'll try to figure out appropriate
# values for these variables momentarily.
my $KELVIN_ROOT='NO_KELVIN_ROOT';
my $KELVIN_BINARY='NO_KELVIN_BINARY';
my $SEQUPDATE_BINARY='NO_SEQUPDATE_BINARY';
my $PEDCOUNT_SCRIPT='NO_PEDCOUNT_SCRIPT';

my $usage = "usage: $0 <configfile> [--directive ... ]\n";
my $config;
my $configFile;
my ($directive, $args);
my $platform = platform_name ();
my $arg;
my $idx = 0;
my $debug = 0;
my $countable = undef;

# For all these, we allow environment variables to override everything, even if
# values were set during installation.
if ($ENV{KELVIN_ROOT}) {
    ($KELVIN_ROOT !~ /no_kelvin_root/i)
	and warner ("overriding installed KELVIN_ROOT with '$ENV{KELVIN_ROOT}' from environment");
    $KELVIN_ROOT = $ENV{KELVIN_ROOT};
} elsif ($KELVIN_ROOT =~ /no_kelvin_root/i) {
    $KELVIN_ROOT = dirname ($0);
    warner ("no KELVIN_ROOT defined by installation, using '$KELVIN_ROOT'");
}

# Instead of 'use'ing our support modules up above, we 'require' them after
# we've had a chance to add KELVIN_ROOT to @INC.
unshift (@INC, $KELVIN_ROOT);
require KelvinDataset;
KelvinDataset->VERSION (1.00);
require KelvinConfig;
KelvinConfig->VERSION (1.00);
require KelvinFamily;
KelvinFamily->VERSION (1.00);

if ($ENV{KELVIN_BINARY}) {
    ($KELVIN_BINARY !~ /no_kelvin_binary/i)
	and warner ("overriding installed KELVIN_BINARY with '$ENV{KELVIN_BINARY}' from environment");
    $KELVIN_BINARY = $ENV{KELVIN_BINARY};
} elsif ($KELVIN_BINARY =~ /no_kelvin_binary/i) {
    if (-x ($KELVIN_BINARY = find_versioned_kelvin ($KELVIN_ROOT))) {
	warner ("no KELVIN_BINARY defined by installation, using '$KELVIN_BINARY'");
    } elsif (-x ($KELVIN_BINARY = "$KELVIN_ROOT/kelvin.$platform")) {
	warner ("no KELVIN_BINARY defined by installation, using '$KELVIN_BINARY'");
    } elsif (-x ($KELVIN_BINARY = "$KELVIN_ROOT/bin/kelvin.$platform")) {
	warner ("no KELVIN_BINARY defined by installation, using '$KELVIN_BINARY'");
    } else {
	error ("no kelvin binary (kelvin-x.y.z or kelvin.$platform) found under $KELVIN_ROOT");
    }
}

if ($ENV{SEQUPDATE_BINARY}) {
    ($SEQUPDATE_BINARY !~ /no_sequpdate_binary/i)
	and warner ("overriding installed SEQUPDATE_BINARY with '$ENV{SEQUPDATE_BINARY}' from environment");
    $SEQUPDATE_BINARY = $ENV{SEQUPDATE_BINARY};
} elsif ($SEQUPDATE_BINARY =~ /no_sequpdate_binary/i) {
    if (-x ($SEQUPDATE_BINARY = "$KELVIN_ROOT/calc_updated_ppl")) {
	warner ("no SEQUPDATE_BINARY defined by installation, using '$SEQUPDATE_BINARY'");
    } elsif (-x ($SEQUPDATE_BINARY = "$KELVIN_ROOT/seq_update/calc_updated_ppl")) {
	warner ("no SEQUPDATE_BINARY defined by installation, using '$SEQUPDATE_BINARY'");
    } else {
	$SEQUPDATE_BINARY = 'no_sequpdate_binary';
    }
}

if ($ENV{PEDCOUNT_SCRIPT}) {
    ($PEDCOUNT_SCRIPT !~ /no_pedcount_script/i)
	and warner ("overriding installed PEDCOUNT_SCRIPT with '$ENV{PEDCOUNT_SCRIPT}' from environment");
    $PEDCOUNT_SCRIPT = $ENV{PEDCOUNT_SCRIPT};
} elsif ($PEDCOUNT_SCRIPT =~ /no_pedcount_script/i) {
    if (-x ($PEDCOUNT_SCRIPT = "$KELVIN_ROOT/PedCount.pl")) {
	warner ("no PEDCOUNT_SCRIPT defined by installation, using '$PEDCOUNT_SCRIPT'");
    } else {
	$PEDCOUNT_SCRIPT = 'no_pedcount_script';
    }
}

($configFile = shift (@ARGV))
    or die ($usage);
($config = KelvinConfig->new ($configFile))
    or error ("new KelvinConfig failed: $KelvinConfig::errstr");
if (@ARGV) {
    while (defined ($directive = $ARGV[$idx++])) {
	($directive =~ s/^--//) or die ($usage);
	$args = undef;
	while (defined ($ARGV[$idx]) && $ARGV[$idx] !~ /^--/) {
	    $arg = $ARGV[$idx++];
	    $args = (defined ($args)) ? $args .= " $arg" : $arg;
	}
	($config->addDirective ($directive, $args))
	    or error ("$KelvinConfig::errstr on command line");
    }
    $config->validate
	or error ("$KelvinConfig::errstr");
}
($debug) and print Dumper ($config);
(! ($config->isConfigured ("Multipoint") ||
    $config->isConfigured ("CountFile") ||
    $config->isConfigured ("QT") ||
    $config->isConfigured ("QTT") ||
    $config->isConfigured ("SkipPedCount") ||
    $PEDCOUNT_SCRIPT =~ /no_pedcount_script/i))
    and $countable = 1;

if ($config->isConfigured ("EstimateFrequency")) {
    estimate_frequency ($config);
    (! $config->isConfigured ("SkipAnalysis")) 
	and $config->addDirective ("FrequencyFile", "freq.dat");
}

($config->isConfigured ("GenerateKeywords"))
    and generate_keywords ($config);

($config->isConfigured ("SkipAnalysis"))
    and exit (0);

if ($config->isConfigured ("Epistasis")) {
    run_epistasis ($config);
} else {
    just_run_kelvin ($config, @ARGV);
}

exit (0);

sub generate_keywords
{
    my ($config) = @_;
    my $href = {};
    my $dataset;

    $$href{PedigreeFile} = $ {$config->isConfigured ("PedigreeFile")}[0];
    $$href{LocusFile} = $ {$config->isConfigured ("LocusFile")}[0];
    $$href{MapFile} = $ {$config->isConfigured ("MapFile")}[0];
    $$href{FrequencyFile} = $ {$config->isConfigured ("FrequencyFile")}[0];
    $dataset = KelvinDataset->new ($href)
	or error ("KelvinDataset->new failed, $KelvinDataset::errstr");

    # First do the configuration directives...
    print ($config->isConfigured ("SexLinked") ? "XC\n" : "AUC\n");
    if ($dataset->microsats) {
	print (($dataset->snps) ? "MXM\n" : "SNP\n");
    } else {
	print "MSAT\n";
    }
    print "How do we determine homogeneity VS heterogeneity?\n";
    if ($config->isConfigured ("MarkerToMarker")) {
	print "M2M\n";
	if (($ {$config->isConfigured ("MarkerToMarker")}[0]) eq "adjacent") {
	    print "ADJM\n";
	} else {
	    print "ALLM\n";
	}
    } else {
	print "T2M\n";
    }
    if ($config->isConfigured ("QT")) {
	print "QT\n";
    } elsif ($config->isConfigured ("QTT")) {
	print "QTT\n";
    } else {
	print "DT\n";
    }
#    &&&
    
    # Read first pedigree
#    defined ($ped = $dataset->readFamily) 
#	or error ("readFamily failed, $KelvinDataset::errstr");
#    
#    if (($pedsize = scalar (@$ped)) == 1) {
#	($aref = $config->isConfigured ("TraitPrevalence"))
#	    or error ("EstimateFrequency with cases and controls requires TraitPrevalence");
#	$prevalence = $$aref[0];
#	    and error ("EstimateFrequency is incompatible with QT/QTT and cases and controls.");
#	$traits = $dataset->traitOrder;
#	(scalar (@$traits) == 0)
#	    and error ("Dataset contains no affection status (trait). EstimateFrequency requires a dichotomous trait.");
#	$trait = $$traits[0];
#	(scalar (@$traits) > 1)
#	    and warn ("Using trait '$trait' to distinguish cases from controls for allele frequency estimation.");
#
#    } elsif ($pedsize == 3) {
#	($config->isConfigured ("TraitPrevalence"))
#	    and error ("EstimateFrequency with trios is incompatible with TraitPrevalence");
#    } else {
#	error ("EstimateFrequency is only legal with cases and controls or trios");
#    }


}

sub estimate_frequency
{
    my ($config) = @_;
    my $dataset;
    my ($markers, $traits);
    my ($marker, $trait);
    my (%transmitted, %nontransmitted);
    my ($prevalence, %cases, %controls);
    my ($case, $control);
    my $xchr = undef;
    my $ped;
    my $pedsize;
    my ($dad, $mom) = (undef, undef);
    my ($dadgeno, $momgeno, $kidgeno);
    my $pheno;
    my $allele;
    my $href = {};
    my $aref;
    my $va;

    $$href{PedigreeFile} = $ {$config->isConfigured ("PedigreeFile")}[0];
    $$href{LocusFile} = $ {$config->isConfigured ("LocusFile")}[0];
    $$href{MapFile} = $ {$config->isConfigured ("MapFile")}[0];
    $dataset = KelvinDataset->new ($href)
	or error ("KelvinDataset->new failed, $KelvinDataset::errstr");
    ($dataset->microsats)
	and error ("EstimateFrequency is incompatible with microsatellite datsets");
    $markers = $dataset->markerOrder;
    map { $transmitted{$_} = {}; $nontransmitted{$_} = {}; } @$markers;
    ($config->isConfigured ("SexLinked")) and $xchr = 1;

    # Read first pedigree, and validate pedigree size against config directives. Currently
    # we only estimate allele frequencies for cases-n-controls or trios.
    defined ($ped = $dataset->readFamily) 
	or error ("readFamily failed, $KelvinDataset::errstr");
    if (($pedsize = scalar (@$ped)) == 1) {
	($aref = $config->isConfigured ("TraitPrevalence"))
	    or error ("EstimateFrequency with cases and controls requires TraitPrevalence");
	$prevalence = $$aref[0];
	($config->isConfigured ("QT") || $config->isConfigured ("QTT"))
	    and error ("EstimateFrequency is incompatible with QT/QTT and cases and controls.");
	$traits = $dataset->traitOrder;
	(scalar (@$traits) == 0)
	    and error ("Dataset contains no affection status (trait). EstimateFrequency requires a dichotomous trait.");
	$trait = $$traits[0];
	(scalar (@$traits) > 1)
	    and warn ("Using trait '$trait' to distinguish cases from controls for allele frequency estimation.");

    } elsif ($pedsize == 3) {
	($config->isConfigured ("TraitPrevalence"))
	    and error ("EstimateFrequency with trios is incompatible with TraitPrevalence");
    } else {
	error ("EstimateFrequency is only legal with cases and controls or trios");
    }

    if ($pedsize == 1) {
	# Cases and controls. Loop over all individuals.
	while (@$ped) {
	    (scalar (@$ped) == $pedsize)
		or error ("Pedigree ". $$ped[0]->pedid. " is a different size than preceding pedigrees. EstimateFrequency requires that all pedigrees be the same size.");

	    # FIXME: we should be checking for the Phenocodes directive
	    # instead of assuming (0, 1, 2) forDT.
	    if (($pheno = $$ped[0]->getTrait ($trait)) == 1) {
		record_case_control ($$ped[0], \%controls, $xchr, $markers);
		# call sub with \%controls
	    } elsif ($pheno == 2) {
		record_case_control ($$ped[0], \%cases, $xchr, $markers);
	    }
	    ($ped = $dataset->readFamily) or last;
	}
	defined ($ped)
	    or error ("readFamily failed, $KelvinDataset::errstr");
	
	foreach $marker (@$markers) {
	    %$href = ();
	    map {
		$$href{$_} = '';
	    } (keys (%{$cases{$marker}}), keys (%{$controls{$marker}}));
	    (scalar (@$aref = sort (keys (%$href))) == 2)
		or error ("marker '$marker' has more than two alleles: ". join (', ', keys (%$href)));
	    $case = ($cases{$marker}{$$aref[0]} == 0) ? 0.0001 :
		(($cases{$marker}{$$aref[1]} == 0) ? 0.9999 : 
		 $cases{$marker}{$$aref[0]} / ($cases{$marker}{$$aref[0]} + $cases{$marker}{$$aref[1]}));
	    $control = ($controls{$marker}{$$aref[0]} == 0) ? 0.0001 :
		(($controls{$marker}{$$aref[1]} == 0) ? 0.9999 : 
		 $controls{$marker}{$$aref[0]} / ($controls{$marker}{$$aref[0]} + $controls{$marker}{$$aref[1]}));
	    $$href{$$aref[0]} = sprintf ("%.04f", $prevalence * $case + (1 - $prevalence) * $control);
	    $$href{$$aref[1]} = sprintf ("%.04f", 1 - $$href{$$aref[0]});
	    $dataset->setAlleleFreqs ($marker, $href);
	}
	    
    } else {
	# Trios. Loop over all pedigrees. Skip pedigrees that contain ungenotyped individuals.
	while (@$ped) {
	    (scalar (@$ped) == $pedsize)
		or error ("Pedigree ". $$ped[0]->pedid. " is a different size than preceding pedigrees. EstimateFrequency requires that all pedigrees be the same size.");
	    record_trios ($ped, \%transmitted, \%nontransmitted, $xchr, $markers);
	    ($ped = $dataset->readFamily) or last;
	}
	defined ($ped = $dataset->readFamily)
	    or error ("readFamily failed, $KelvinDataset::errstr");

	foreach $marker (@$markers) {
	    @$aref = keys (%{$nontransmitted{$marker}});
	    (scalar (@$aref) == 2) 
		or error ("marker '$marker' has more than two alleles: ". join (', ', @$aref));
	    $href = { $$aref[0] => sprintf ("%.04f", $nontransmitted{$marker}{$$aref[0]} / 
					    ($nontransmitted{$marker}{$$aref[0]} +
					     $nontransmitted{$marker}{$$aref[1]})) };
	    $$href{$$aref[1]} = sprintf ("%.04f", 1 - $$href{$$aref[0]});
	    $dataset->setAlleleFreqs ($marker, $href);
	}
    }
    
    $dataset->writeFreqfile ("freq.dat")
	or error ("writeFreqfile failed: $KelvinDataset::errstr");
    return (1);
 }


sub record_case_control
{
    my ($ind, $cat, $xchr, $markers) = @_;
    my $marker;
    my $geno;
    my $href;
    
    $href = $ind->structure;
    foreach $marker (@$markers) {
	$geno = $ind->getGenotype ($marker);
	($$geno[0] == 0 || $$geno[1] == 0) and return (0);
	# On X-chr, males only have one allele, coded as homozygous. Don't double count:
	($xchr && $$href{sex} == 1) and shift (@$geno);
	map {
	    exists ($$cat{$marker}{$_}) or $$cat{$marker}{$_} = 0;
	    $$cat{$marker}{$_}++;
	} @$geno;
    }
    return (1);
}


sub record_trios
{
    my ($ped, $xm, $nxm, $xchr, $markers) = @_;
    my ($dadgeno, $momgeno, $kidgeno);
    my ($dad, $mom, $kid);
    my $marker;
    my $href;
    my $va = 0;

    while ($va <= scalar (@$ped)) {
	$$ped[0]->genotyped or return (0);
	$href = $$ped[0]->structure;
	if ($$href{dadid} == 0 && $$href{momid} == 0) {
	    if ($$href{sex} == 1) {
		$dad = shift (@$ped);
	    } else {
		$mom = shift (@$ped);
	    }
	}
	$va++;
    }
    $href = ($kid = $$ped[0])->structure;

    foreach $marker (@$markers) {
	$dadgeno = $dad->getGenotype ($marker);
	$momgeno = $mom->getGenotype ($marker);
	$kidgeno = $kid->getGenotype ($marker);
	($$dadgeno[0] == 0 || $$dadgeno[1] == 0 || $$momgeno[0] == 0 || $$momgeno[1] == 0 || 
	 $$kidgeno[0] == 0 || $$kidgeno[1] == 0)
	    and next;
	map {
	    exists ($$xm{$marker}{$_}) or $$xm{$marker}{$_} = 0;
	    exists ($$nxm{$marker}{$_}) or $$nxm{$marker}{$_} = 0;
	} (@$dadgeno, @$momgeno, @$kidgeno);
	map { $$nxm{$marker}{$_}++; } @$momgeno;
	if (! $xchr) {
	    map { $$nxm{$marker}{$_}++; } @$dadgeno;
	    map {
		$$xm{$marker}{$_}++;
		$$nxm{$marker}{$_}--;
	    } @$kidgeno;
	} elsif ($$href{sex} == 1) {
	    # X-chromosome, male child
	    $$xm{$marker}{$$kidgeno[0]}++;
	    $$nxm{$marker}{$$kidgeno[0]}--;
	    $$nxm{$marker}{$$dadgeno[0]} += 0.5;
	} else {
	    # X-chromosome, female child
	    $$nxm{$marker}{$$dadgeno[0]} += 1.5;
	    map {
		$$xm{$marker}{$_}++;
		$$nxm{$marker}{$_}--;
	    } @$kidgeno;
	}
    }
    return (1);
}


sub run_epistasis
{
    my ($config) = @_;
    my $epidataset;
    my $epimarker;
    my $epigeno;
    my $origdataset;
    my $individual;
    my %individuals;
    my ($multipoint, $ld, $extramods) = (undef, undef, undef);
    my $undefpheno;
    my $trait;
    my %conffiles = ();
    my @sequpdateargs = ('-e');
    my @countargs = ();
    my @lcmap = ();
    my $ret;
    my $va;

    my $struct;
    my $args;
    my $href = {};
    my $aref;

    ($SEQUPDATE_BINARY =~ /no_sequpdate_binary/i)
	and error ("no sequpdate binary found");
    ($config->isConfigured ("Multipoint")) and $multipoint = 1;
    ($config->isConfigured ("LD")) and $ld = 1;
    ($config->isConfigured ("ExtraMODs")) and $extramods = 1;

    # Configuration validation means I don't have to check return codes here
    $conffiles{PedigreeFile} = $ {$config->isConfigured ("EpistasisPedigreeFile")}[0];
    $conffiles{LocusFile} = $ {$config->isConfigured ("EpistasisLocusFile")}[0];
    $epimarker = $ {$config->isConfigured ("Epistasis")}[0];
    $aref = $config->isConfigured ("PhenoCodes");
    $undefpheno = $$aref[0];
    ($countable) and $conffiles{CountFile} = "counts.dat";

    map { $$href{$_} = $conffiles{$_} } qw/PedigreeFile LocusFile/;
    ($epidataset = KelvinDataset->new ($href))
	or error ("KelvinDataset->new failed, $KelvinDataset::errstr");
    $epidataset = $epidataset->copy ({preserve => [$epimarker]});
    
    while ($individual = $epidataset->readIndividual) {
	$struct = $individual->structure;
	$aref = $individual->getGenotype ($epimarker);
	$individuals{"P$$struct{pedid}I$$struct{indid}"} = join ('_', sort (@$aref));
    }
    $epidataset->close;

    # Load up %conffiles
    $conffiles{configfile} = $config->filename;
    $conffiles{PedigreeFile} = $ {$config->isConfigured ("PedigreeFile")}[0];
    $conffiles{LocusFile} = $ {$config->isConfigured ("LocusFile")}[0];
    $conffiles{BayesRatioFile} = $ {$config->isConfigured ("BayesRatioFile")}[0];
    if (! $multipoint) {
	$conffiles{PPLFile} = ($args = $config->isConfigured ("PPLFile")) ? $$args[0] : 'ppl.out';
	push (@sequpdateargs, '-O', $conffiles{BayesRatioFile}, '-R', $conffiles{PPLFile});
    } else {
	push (@sequpdateargs, '-m', '-R', $conffiles{BayesRatioFile});
    }
    ($args = $config->isConfigured ("MODFile")) and $conffiles{MODFile} = $$args[0];
    $config->addDirective ("LiabilityClasses", epistasis_LC_map ($ld, \@lcmap, \%individuals));

    map { $$href{$_} = $conffiles{$_} } qw/PedigreeFile LocusFile/;
    ($origdataset = KelvinDataset->new ($href))
        or die ("FATAL: new KelvinDataset failed, $KelvinDataset::errstr\n");
    $aref = $origdataset->traitOrder;
    (scalar (@$aref) == 0) and error ("dataset contains no trait data");
    $trait = $$aref[0];
    $epidataset = $origdataset->copy ({purge => [$epimarker]});
    $epidataset->addTrait ('EpistasisClass', 'C', 'end')
	or error ("KelvinDataset->addTrait failed, $KelvinDataset::errstr");
    ($origdataset = KelvinDataset->new ($href))
    	or error ("KelvinDataset->new failed, $KelvinDataset::errstr");

    $$href{backupfile} = 0;
    for ($va = 0; $va < scalar (@lcmap); $va++) {
	map {$$href{$_} = $conffiles{$_}.".pass$va"} qw/PedigreeFile LocusFile/;
	$epidataset->write ($href);
	while ($individual = $origdataset->readIndividual) {
	    $individual->map ($epidataset);
	    $struct = $individual->structure;
	    $epigeno = $individuals{"P$$struct{pedid}I$$struct{indid}"};
	    if (exists ($lcmap[$va]{$epigeno})) {
		$individual->setTrait ("EpistasisClass", $lcmap[$va]{$epigeno});
	    } else {
		$individual->setTrait ($trait, $undefpheno);
		$individual->setTrait ("EpistasisClass", 1);
	    }
	    $individual->write;
	}
	$origdataset->close;
	$epidataset->close;
	
	map {
	    exists ($conffiles{$_}) and $config->setDirective ($_, $conffiles{$_}. ".pass$va");
	} qw/PedigreeFile LocusFile BayesRatioFile MODFile/;
	$config->write ({configfile => $conffiles{configfile}. ".pass$va",
			 backupfile => 0, nolocal => 1});
	push (@sequpdateargs, $conffiles{BayesRatioFile}. ".pass$va");
	if ($countable && ! $epidataset->microsats) {
	    (($ret = system ($PEDCOUNT_SCRIPT, "-count", "-write", "-quiet",
			     "-config", $conffiles{configfile}. ".pass$va")) != 0)
		and error ("$PEDCOUNT_SCRIPT failed, " . ($ret == -1) ? "$!" : "status $?");
	    rename ("PC1_Counts.Dat", $conffiles{CountFile}. ".pass$va");
	    rename ("PC1_Pedigrees.Dat", $conffiles{PedigreeFile}. ".pass$va");
	    unlink ("PC1_Data.Dat");
	    @countargs = ("--CountFile", $conffiles{CountFile}. ".pass$va");
	}

	(($ret = system ($KELVIN_BINARY, $conffiles{configfile}. ".pass$va", @countargs)) != 0) 
	    and error ("$KELVIN_BINARY $conffiles{configfile}.pass$va failed".
		       ($ret == -1) ? "$!" : "status $?");
    }
    if (scalar (@lcmap) == 1) {
	# If we only ran Kelvin once, clean up the inputs and rename the outputs
	map { rename ($conffiles{$_}.'.pass0', $conffiles{$_}) } qw/BayesRatioFile MODFile/;
	map { unlink ($conffiles{$_}.'.pass0') } qw/PedigreeFile LocusFile CountFile configfile/;
    } else {
	# Perform the sequential update, massage the MOD files, and clean up 
	(exists ($conffiles{PPLFile})) and unlink ($conffiles{PPLFile});
	(($ret = system ($SEQUPDATE_BINARY, @sequpdateargs)) != 0)
	    and error ("$SEQUPDATE_BINARY failed, " . ($ret == -1) ? "$!" : "status $?");
	
	if (exists ($conffiles{MODFile})) {
	    if (! $multipoint) {
		epistasis_merge_TP_mod ($conffiles{MODFile}, $extramods);
	    } else {
		epistasis_merge_MP_mod ($conffiles{MODFile});
	    }
	}
	
	for ($va = 0; $va < scalar (@lcmap); $va++) {
	    map {
		(-f $conffiles{$_}. ".pass$va") and unlink ($conffiles{$_}. ".pass$va");
	    } qw/PedigreeFile LocusFile BayesRatioFile MODFile CountFile configfile/;
	}
    }
    exit (0);
}


# This will need to be significantly retooled if we ever move to multi-marker 
# epistasis. For the moment, we assume a single SNP. We need to provide three
# pieces of information to the epistasis routine: the number of liability classes,
# the number of Kelvin runs, and a mapping of genotypes to liability class for
# each Kelvin run. We load the pass-by-reference array with one genotype-to-LC
# map for each kelvin run, and return the number of liability classes directly.
sub epistasis_LC_map
{
    my ($ld, $aref, $individuals) = @_;
    my $href = {};
    my $count = 0;
    my $geno;

    map { $$href{$_} = defined ($$href{$_}) ? $$href{$_} + 1 : 1 } values (%$individuals);
    exists ($$href{'0_0'}) and delete ($$href{'0_0'});
    foreach (qw/1_1 1_2 2_2/) {
	if (exists ($$href{$_})) {
	    $$href{$_} = ++$count;
	} else {
	    ($geno = $_) =~ s/_/,/;
	    warner ("no individuals in pedigree with $geno genotype at epistasis marker");
	}
    }
    if ($count != 3) {
	warner ("Epistasis analysis reduced to $count class(es) due to limited observed genotypes.");
	@$aref = ($href);
	return ($count);
    }
    
    if ($ld) {
	@$aref = ({'1_1', => 1, '1_2' => 2, '2_2' => 3});
	return (3);
    } else {
	@$aref = ({'1_1', => 1, '1_2' => 1, '2_2' => 2},
		  {'1_1', => 1, '1_2' => 2, '2_2' => 2});
	return (2);
    }
}

# Assumes epistasis with a single SNP
sub epistasis_merge_MP_mod
{
    my ($modfile) = @_;
    my ($fh0, $fh1, $outfh);
    my (@flds0, @flds1);
    my ($pen1, $pen2);
    my $line;
    my $modidx = 2;

    $outfh = IO::File->new (">$modfile") or die ("open '$modfile' failed, $!\n");
    $fh0 = IO::File->new ( "$modfile.pass0") or die ("open '$modfile.pass0' failed, $!\n");
    $fh1 = IO::File->new  ("$modfile.pass1") or die ("open '$modfile.pass1' failed, $!\n");
    
    # Version line
    $outfh->print ($fh0->getline);
    $fh1->getline;

    # Header line
    ($line = $fh0->getline) =~ s/LC2PV(\([Dd,]+\))$/LC2PV$1 LC3PV$1/;
    $outfh->print ($line);
    $fh1->getline;

    while ($line = $fh0->getline) {
	@flds0 = split (/\s+/, $line);
	@flds1 = split (/\s+/, $fh1->getline);
	
	if ($flds0[$modidx] >= $flds1[$modidx]) {
	    ($pen1, $pen2) = splice (@flds0, -2, 2);
	    $outfh->print (join (' ', @flds0, $pen1, $pen1, $pen2), "\n");
	} else {
	    ($pen1, $pen2) = splice (@flds1, -2, 2);
	    $outfh->print (join (' ', @flds1, $pen1, $pen2, $pen2), "\n");
	}
    }
    $outfh->close;
    $fh0->close;
    $fh1->close;
    return (1);
}

# Again, assumes a single SNP
sub epistasis_merge_TP_mod
{
    my ($modfile, $extramods) = @_;
    my ($fh0, $fh1, $outfh);
    my (@flds0, @flds1);
    my ($pen1, $pen2);
    my $line;
    my $modidx = ($extramods) ? 1 : 0;

    $outfh = IO::File->new (">$modfile") or die ("open '$modfile' failed, $!\n");
    $fh0 = IO::File->new ( "$modfile.pass0") or die ("open '$modfile.pass0' failed, $!\n");
    $fh1 = IO::File->new  ("$modfile.pass1") or die ("open '$modfile.pass1' failed, $!\n");

    # Version line
    $outfh->print ($fh0->getline);
    $fh1->getline;

    while ($line = $fh0->getline) {
	# Marker line
	$outfh->print ($line);
	$fh1->getline;

	# Header line
	($line = $fh0->getline) =~ s/LC2PV(\([Dd,]+\))$/LC2PV$1 LC3PV$1/;
	$outfh->print ($line);
	$fh1->getline;

	# Overall MOD line
	@flds0 = split (/\s+/, $fh0->getline);
	@flds1 = split (/\s+/, $fh1->getline);

	if ($flds0[$modidx] >= $flds1[$modidx]) {
	    ($pen1, $pen2) = splice (@flds0, -2, 2);
	    $outfh->print (join (' ', @flds0, $pen1, $pen1, $pen2), "\n");
	    if ($extramods) {
		# Mod at Theta==0 line
		@flds0 = split (/\s+/, $fh0->getline);
		($pen1, $pen2) = splice (@flds0, -2, 2);
		$outfh->print (join (' ', @flds0, $pen1, $pen1, $pen2), "\n");
		$fh1->getline;
	    }
	} else {
	    ($pen1, $pen2) = splice (@flds1, -2, 2);
	    $outfh->print (join (' ', @flds1, $pen1, $pen2, $pen2), "\n");
	    if ($extramods) {
		# Mod at Theta==0 line
		@flds1 = split (/\s+/, $fh1->getline);
		($pen1, $pen2) = splice (@flds1, -2, 2);
		$outfh->print (join (' ', @flds1, $pen1, $pen2, $pen2), "\n");
		$fh0->getline;
	    }
	}
    }
    $outfh->close;
    $fh0->close;
    $fh1->close;
    return (1);
}

sub just_run_kelvin
{
    my ($config, @argv) = @_;
    my $dataset;
    my $args;
    my $ret;
    
    $args = $config->isConfigured ("FrequencyFile");
    # This has the effect of validating allele frequencies
    $dataset = KelvinDataset->new ({freqfile => $$args[0]})
	or error ($KelvinDataset::errstr);
    $dataset->close;

    if ($countable && ! $dataset->microsats) {
	(($ret = system ($PEDCOUNT_SCRIPT, "-count", "-write", "-quiet",
			 "-config", $config->filename)) != 0)
	    and error ("$PEDCOUNT_SCRIPT failed, " . ($ret == -1) ? "$!" : "status $?");
	$config->setDirective ("PedigreeFile", "PC1_Pedigrees.Dat");
	$config->setDirective ("CountFile", "PC1_Counts.Dat");
	$config->write ({configfile => "PC1_". $config->filename, backupfile => 0, nolocal => 1});
	(($ret = system ($KELVIN_BINARY, "PC1_". $config->filename)) != 0)
	    and error ("$KELVIN_BINARY failed, " . ($ret == -1) ? "$!" : "status $?");
	map { unlink ("PC1_$_") } ($config->filename, 'Pedigrees.Dat', 'Counts.Dat', 'Data.Dat');
	    
    } else { 
	($config->localDirectives)
	    and $config->write ({nolocal => 1});
	
	(($ret = system ($KELVIN_BINARY, $config->filename, @argv)) != 0)
	    and error ("$KELVIN_BINARY failed, " . ($ret == -1) ? "$!" : "status $?");

	if (($config->localDirectives) && (-f $config->filename. ".old")) {
	    unlink ($config->filename);
	    rename ($config->filename. ".old", $config->filename);
	}
    }
}

sub platform_name
{
    my $platform;

    $platform = `uname -m`;
    $platform .= '-' . `uname -s`;
    $platform =~ tr/ \n/-/d;
    return ($platform);
}

sub find_versioned_kelvin
{
    my ($dir) = @_;
    my $file;
    my @arr;

    # Look in the directory that we were passed (prolly KELVIN_ROOT)
    opendir (DIRH, $dir) or error ("opendir '$dir' failed, $!");
    while ($file = readdir (DIRH)) {
	$file =~ /^kelvin-\d+\.\d+(?:\.\d+)$/ or next;
	(-x "$dir/$file") or next;
	push (@arr, $file);
    }
    if (! scalar (@arr)) {
	# Nobody home? See if there's a bin subdirectory, and if so, look there
	(-d "$dir/bin" && ($file = find_versioned_kelvin ("$dir/bin")))
	    and return ($file);
	return (undef);
    }
    @arr = reverse (sort (@arr));
    return ("$dir/$arr[0]");
}

sub fatal
{
    die ("FATAL - ABORTING, @_");
}

sub error
{
    die ("ERROR - EXITING, @_\n");
}

sub warner
{
    warn ("WARNING, @_\n");
}


