#!/usr/bin/perl
use strict;
use warnings FATAL=>qw(all);
use Data::Dumper;
use File::Basename;
# KelvinDataset will be required later
# KelvinConfig, ditto
# KelvinFamily, double ditto
no warnings qw(once);

$|=1;

# KELVIN frontend script 
# Copyright 2009, Nationwide Children's Hospital Research Institute
# All rights reserved. Permission is hereby granted to use this software
# for non-profit educational purposes only.

# These three variables are typically set during the 'make install'. If the
# values are still 'NO_<variable_name>', then the script you are reading
# was not properly installed. Never fear, we'll try to figure out appropriate
# values for these variables pretty soon.
my $KELVIN_ROOT='NO_KELVIN_ROOT';
my $KELVIN_BINARY='NO_KELVIN_BINARY';
my $SEQUPDATE_BINARY='NO_SEQUPDATE_BINARY';

# Used globally
my %keylabels;
my %equivalentkeys;
my $config;
my $svn_version='$Id$';
my %phenocodes;
my %phenomap;
my ($UNDEFINED, $UNAFFECTED, $AFFECTED) = (0, 1, 2);

my $usage = "usage: $0 <configfile> [--directive ... ]\n";
my $platform = platform_name ();
my ($directive, $args, $arg);
my $configFile;
my $dataset;
my $postdataset = undef;
my $misordered = undef;
my $makeped = undef;
my @kelvinargs = ();
my $family;
my @cleanup;
my $idx = 0;
my $debug = 0;
my $href;
my $aref;
my $ret;

my %freqState = ( estimate => 1, xchr => 0, prevalence => 0, qt => 0, affected => 2,
		  kelvinargs => []);
my %countState = ( countable => 1, imprinting => 0, cases => 0, controls => 0, skipweighting => 0,
		   pedigreefile => undef, countfile => undef, xchr => 0, precounted => 0,
		   postcounted => 0, uninformative => 0);
my %epiState = ( passes => 0, extramods => 0, ld => 0, multipoint => 0, trait => undef, 
		 xchr => 0, sequpdateargs => [] );

print ("Kelvin version $svn_version\n");
# Nail down values for those UPPERCASE VARIABLES, as needed
check_paths ();

# Read config file and process any extra command line directives
($configFile = shift (@ARGV))
    or die ($usage);
($config = KelvinConfig->new ($configFile))
    or error ("new KelvinConfig failed: $KelvinConfig::errstr");
if (@ARGV) {
    while (defined ($directive = $ARGV[$idx++])) {
	($directive =~ s/^--//) or die ($usage);
	$args = undef;
	while (defined ($ARGV[$idx]) && $ARGV[$idx] !~ /^--/) {
	    $arg = $ARGV[$idx++];
	    $args = (defined ($args)) ? $args .= " $arg" : $arg;
	}
	($config->addDirective ($directive, $args))
	    or error ("$KelvinConfig::errstr on command line");
    }
    $config->validate
	or error ("$KelvinConfig::errstr");
}
$aref = $config->isConfigured ("PhenoCodes");
@phenocodes{$UNDEFINED, $UNAFFECTED, $AFFECTED} = split (/,\s*/, $$aref[0]);
map { defined ($phenocodes{$_}) and $phenomap{$phenocodes{$_}} = $_ } keys (%phenocodes);

# Open dataset (that is, read the locus, map and freq files, and set up the
# pedigree file for reading). We include the freq file, if one is available,
# because prior knowledge of the presence of microsats will save us effort
# later.
$$href{PedigreeFile} = $ {$config->isConfigured ("PedigreeFile")}[0];
$$href{LocusFile} = $ {$config->isConfigured ("LocusFile")}[0];
$$href{MapFile} = $ {$config->isConfigured ("MapFile")}[0];
($aref = $config->isConfigured ("FrequencyFile"))
    and $$href{FrequencyFile} = $$aref[0];
$dataset = KelvinDataset->new ($href)
    or error ("KelvinDataset->new failed, $KelvinDataset::errstr");
$dataset->setUndefPhenocode ($phenocodes{$UNDEFINED});

# Set up for allele frequency estimation. This will also validate the
# conditions for frequency estimation that we can dope out from the
# config and the dataset, short of reading the pedigree file.
setup_frequency_estimation (\%freqState, $config, $dataset);

# Set up for epistasis analysis, if called for.
setup_epistasis (\%epiState, $config, $dataset, \%countState);
#print Dumper (\%epiState);

# Same for pedigree counting, only if Epistasis is turned off. If
# Epistasis is on, setup_epistasis has already set up ped counting
# for each pass of the epistasis run
($epiState{passes}) or setup_pedcount (\%countState, $config, $dataset);

while ($family = $dataset->readFamily) {
    ($freqState{estimate}) and count_alleles (\%freqState, $family);
    if ($epiState{passes}) {
	epistasis_family (\%epiState, $family);
    } else {
	($countState{countable}) and count_family (\%countState, $family);
	(defined ($makeped)) or $makeped = $family->origfmt;
	($makeped eq $family->origfmt)
	    or error ("Pedigree file contains mixed pre- and post-MAKEPED pedigrees");
	if ($family->origfmt eq 'pre') {
	    if (! defined ($postdataset)) {
		$postdataset = $dataset->copy;
		push (@cleanup, $postdataset->pedigreefile . ".post");
		$postdataset->writePedigreefile ({pedigreefile => $cleanup[-1]})
		    or error ("KelvinDataset->writePedigreefile failed, $KelvinDataset::errstr");
	    }
	    $family = $family->map ($postdataset);
	    $family->write;
	}
    }
}
(! defined ($family)) and error ($KelvinDataset::errstr);

($freqState{estimate}) and finish_frequency_estimation (\%freqState, $dataset);

if ($epiState{passes}) {
    # run_epistasis() needs to know if microsatellites have been detected since setup_epistasis()
    run_epistasis (\%epiState, \%freqState, $config, $dataset->microsats);
} else {
    ($countState{countable}) and write_pedcount (\%countState, $dataset);

    # write_pedcount() could disable pedigree counting at the last second.
    # If it did, and if pre-MAKEPED pedigree were observed, we have to use
    # the pedigrees we copied for the analysis.
    (! $countState{countable} && defined ($postdataset))
	and push (@kelvinargs, "--PedigreeFile", $postdataset->pedigreefile);
    
    if ($config->isConfigured ("SkipAnalysis")) {
	warner ("Skipping analysis.\n");
    } else {
	if ($config->localDirectives) {
	    push (@cleanup, $config->filename . ".tmp");
	    $config->write ({configfile => $cleanup[-1], nolocal => 1, backupfile => 1});
	}
	(($ret = system ($KELVIN_BINARY, $config->filename, @ARGV, @{$freqState{kelvinargs}}, @{$countState{kelvinargs}}, @kelvinargs)) != 0)
	    and error ("$KELVIN_BINARY failed, ", ($ret == -1) ? "$!" : "status $?");
	($countState{countable})
	    and remove (@countState{qw/pedigreefile countfile/});
    }
}
scalar (@cleanup) and remove (@cleanup);


exit (0);

# An alias for unlink so we can easily disable cleaning up temp files,
# for debugging purposes
sub remove 
{
    # print ("unlink ", join (' ', @_), "\n");
    unlink (@_);
}

#
# In general, we'll always try to do pedigree counting, although there are
# a raft of configuration options that necessarily disable counting.
#
sub setup_pedcount
{
    my ($state, $config, $dataset) = @_;
    my $traits;
    my $href;
    my $va;
    
    # Set this so I don't have to worry about it being undefined later
    $$state{kelvinargs} = [];

    if ($config->isConfigured ("Multipoint") ||
	$config->isConfigured ("CountFile") ||
	$config->isConfigured ("QT") ||
	$config->isConfigured ("QTT") ||
	$config->isConfigured ("SkipPedCount") ||
	$dataset->microsats) {
	warner ("Pedigree counting is disabled due to configuration");
	$$state{countable} = 0;
	return;
    }
    ($config->isConfigured ("SexLinked")) and $$state{xchr} = 1;
    ($config->isConfigured ("Imprinting")) and $$state{imprinting} = 1;
    ($config->isConfigured ("SkipCountWeighting")) and $$state{skipweighting} = 1;
    $$state{pedigreefile} = $dataset->pedigreefile;
    $$state{counts} = [];
    $$state{markers} = $dataset->markerOrder;
    $$state{pedlabels} = {};
    $$state{traits} = [];
    $$state{uncountedpeds} = [];
    $$state{labelmap} = [];
    $$state{revlabelmap} = [];
    $traits = $dataset->traitOrder;
    push (@{$$state{traits}}, shift (@$traits));
    if (scalar (@$traits) && $config->isConfigured ("LiabilityClasses")) {
	$href = $dataset->getTrait ($$traits[0]);
	($$href{flag} eq 'C') and push (@{$$state{traits}}, shift (@$traits));
    }
    if ($dataset->freqread) {
	for ($va = 0; $va < scalar (@{$$state{markers}}); $va++) {
	    $href = $dataset->getAlleleFreqs ($$state{markers}[$va]);
	    # This will add the alleles to mappings, we'll just ignore the return values
	    get_allele_mapping ($state, $va, [ keys (%$href) ]);
	}
    }
    return;
}

#
# Count phenotype/LC/genotype combinations for each marker. We only count 
# nuclear pedigrees
#
sub count_family
{
    my ($state, $family) = @_;
    my ($dad, $mom, $kids);
    my ($dadkey, $momkey, $key);
    my @kidkeys;
    my @parents;
    my @kids;
    my $geno;
    my $aref;
    my ($va, $vb);

    # We don't count general pedigrees, no way, no how. Save family to write out later.
    if ($family->pedtype eq 'general') {
	push (@{$$state{uncountedpeds}}, $family);
	return;
    }

    $kids = $family->children;

    if ($family->pedtype eq 'casecontrol') {
	if (! $$kids[0]->phenotyped) {
	    # Count every marker for this individual as uninformative
	    $$state{uninformative} += scalar @{$$state{markers}};
	    return;
	}
	$kidkeys[0] = '';
	# Get the trait and any liability class assignment
	map { $kidkeys[0] .= get_trait_mapping ($$kids[0], $_); } @{$$state{traits}};

	# The first character in the key should be the trait/affection status, which has
	# been mapped from the dataset value to 0, 1 or 2 (UNDEFINED, UNAFFECTED, or AFFECTED)
	if (substr ($kidkeys[0], 0, 1) == $UNAFFECTED) {
	    $$state{controls}++;
	} elsif (substr ($kidkeys[0], 0, 1) == $AFFECTED) {
	    $$state{cases}++;
	}

	# And tack on the sex, if matters
	($$state{xchr} || $$state{imprinting}) and 
	    $kidkeys[0] .= ($$kids[0]->sex == 1) ? 'm' : 'f';

	# The per-individual key combined with per-marker genotypes create the pedigree patterns
	for ($va = 0; $va < scalar (@{$$state{markers}}); $va++) {
	    $$state{precounted}++;
	    get_allele_mapping ($state, $va,
				$aref = $$kids[0]->getGenotype ($$state{markers}[$va]));;
	    $geno = ($$aref[0] le $$aref[1]) ? $$aref[0] . $$aref[1] : $$aref[1] . $$aref[0];
	    if ($geno eq '00') {
		$$state{uninformative}++;
		next;
	    }
	    $key = equivalentkey ("_C" . $geno . $kidkeys[0]);
	    
	    if (! exists ($$state{counts}[$va]{$key})) {
		$$state{counts}[$va]{$key} = 1;
		$$state{postcounted}++;
	    } else {
		$$state{counts}[$va]{$key}++;
	    }
	    (! exists $$state{pedlabels}{$key} ||
	     $$state{pedlabels}{$key} < $$state{counts}[$va]{$key})
		and $$state{pedlabels}{$key} = $$state{counts}[$va]{$key};
	}
	
    } else {
	map { push (@kidkeys, '') } @$kids;
	($dad, $mom) = ($family->dad, $family->mom);
	map {
	    $dadkey .= get_trait_mapping ($dad, $_);
	    $momkey .= get_trait_mapping ($mom, $_);
	    for ($va = 0; $va < scalar (@$kids); $va++) {
		$kidkeys[$va] .= get_trait_mapping ($$kids[$va], $_);
	    }
	} @{$$state{traits}};
	if ($$state{xchr} || $$state{imprinting}) {
	    $dadkey .= ($dad->sex == 1) ? 'm' : 'f';
	    $momkey .= ($mom->sex == 1) ? 'm' : 'f';
	    for ($va = 0; $va < scalar (@$kids); $va++) {
		$kidkeys[$va] .= ($$kids[$va]->sex == 1) ? 'm' : 'f';
	    }
	}
	for ($va = 0; $va < scalar (@{$$state{markers}}); $va++) {
	    get_allele_mapping ($state, $va,
				$aref = $dad->getGenotype ($$state{markers}[$va]));
	    $geno = ($$aref[0] le $$aref[1]) ? $$aref[0] . $$aref[1] : $$aref[1] . $$aref[0];
	    $parents[0] = $geno . $dadkey;
	    get_allele_mapping ($state, $va,
				$aref = $mom->getGenotype ($$state{markers}[$va]));
	    $geno = ($$aref[0] le $$aref[1]) ? $$aref[0] . $$aref[1] : $$aref[1] . $$aref[0];
	    $parents[1] = $geno . $momkey;
	    $key = ($$state{xchr} || $$state{imprinting} || $parents[0] le $parents[1]) ? 
		($parents[0] . $parents[1]) : ($parents[1] . $parents[0]);
	    @kids = ();
	    for ($vb = 0; $vb < scalar (@$kids); $vb++) {
		get_allele_mapping ($state, $va,
				    $aref = $$kids[$vb]->getGenotype ($$state{markers}[$va]));
		$geno = ($$aref[0] le $$aref[1]) ? $$aref[0] . $$aref[1] : $$aref[1] . $$aref[0];
		$kids[$vb] = $geno . $kidkeys[$vb];
	    }
	    $key = '_N'. $key . join ('', sort (@kids));
	    $key = equivalentkey ($key);
	    $$state{precounted}++;

	    if (! exists ($$state{counts}[$va]{$key})) {
		$$state{counts}[$va]{$key} = 1;
		$$state{postcounted}++;
	    } else {
		$$state{counts}[$va]{$key}++;
	    }
	    (! exists $$state{pedlabels}{$key} ||
	     $$state{pedlabels}{$key} < $$state{counts}[$va]{$key})
		and $$state{pedlabels}{$key} = $$state{counts}[$va]{$key};
	}
    }
}

sub write_pedcount
{
    my ($state, $dataset) = @_;
    my @pedlabels = ();
    my $counts;
    my $count;
    my $family;
    my @individuals;
    my $key;
    my $pedid;
    my ($geno, $traits, $sex);
    my $average;
    my $str;
    my $va;
    my $n;

    if ($dataset->microsats) {
	$$state{countable} = 0;
	warner ("Microsatellites detected, disabling pedigree counting");
    } elsif ($$state{postcounted} >= $$state{precounted}) {
	$$state{countable} = 0;
	warner ("Pedigree counting results in no savings, disabling");
    } elsif ($$state{precounted} / scalar (@{$$state{markers}}) < scalar (keys (%{$$state{pedlabels}}))) {
	# This compares the number of potentially countable pedigrees against the number
	# of pedigreee patterns. If the former is less, it's (currently) cheaper to just
	# analyze the uncounted pedigrees.
	$$state{countable} = 0;
	warner ("Pedigree counting will not result in savings, disabling");
    } else {
	printf ("Pedigree counting reduces evaluations from $$state{precounted} to $$state{postcounted} (%.2f%%)\n", (1 - $$state{postcounted} / $$state{precounted}) * 100);
	($$state{uninformative} > 0) and printf ("Pedigree counting dropped %d uninformative pedigree/locus combinations\n", $$state{uninformative});
    }

    if ($$state{countable}) {
#	$average = ($$state{cases} + $$state{controls}) / 2;
	$average = $$state{cases};
	($average > 0 && ! $$state{skipweighting})
	    and warner ("Pedigree count weighting (v2) for cases/controls is in effect");
	($$state{cases} != 0) and $$state{cases} = $average / $$state{cases};
	($$state{controls} != 0) and $$state{controls} = $average / $$state{controls};

	$$state{countfile} = $$state{pedigreefile} . ".counts";
	@pedlabels = sort {by_len ($a, $b)} (keys (%{$$state{pedlabels}}));
	open (FH, ">$$state{countfile}");
	print (FH "Marker");
	print (FH map { " ". $_->pedid } @{$$state{uncountedpeds}});
	print (FH map { " " . keylabel ($_) } @pedlabels, "\n");
	for ($va = 0; $va < scalar (@{$$state{markers}}); $va++) {
	    print (FH "$$state{markers}[$va]");
	    print (FH " 1" x scalar (@{$$state{uncountedpeds}}));
	    $counts = $$state{counts}[$va];
	    foreach $key (@pedlabels) {
		if (exists ($$counts{$key})) {
		    # Label will be _C1xxx/_C2xxx for case/control with covariate or imprinting
		    if (! $$state{skipweighting} &&
			(($str) = (keylabel ($key) =~ /^(case|ctrl|_C..[12])/))) {
			if ($str eq "case" ||
			    substr ($str, 0, 2) eq "_C" && substr ($str, 4, 1) eq "2") {
			    $count = sprintf ("%.0f", $$counts{$key} * $$state{cases});
			} else {
			    $count = sprintf ("%.0f", $$counts{$key} * $$state{controls});
			}
		    } else {
			$count = $$counts{$key};
		    }
		} else {
		    $count = 0;
		}
		print (FH " ". $count);
	    }
	    print (FH "\n");
	}
	$$state{pedigreefile} .= ".counted";
	$dataset->writePedigreefile ({pedigreefile => $$state{pedigreefile}});
	push (@{$$state{kelvinargs}}, "--PedigreeFile", $$state{pedigreefile});

	foreach $family (@{$$state{uncountedpeds}}) {
	    $family->write ();
	}
	$n = scalar (@{$$state{traits}});
	foreach $key (@pedlabels) {
	    $pedid = keylabel ($key);
	    if (substr ($key, 0, 2, "") eq '_C') {
		# Case/control
		if ($$state{imprinting} || $$state{xchr}) {
		    ($geno, $traits, $sex) = ($key =~ /(..)(.{$n})(.)/);
		    $sex = ($sex eq 'm') ? 1 : 2;
		} else {
		    ($geno, $traits, $sex) = ($key =~ /(..)(.{$n})/, 1);
		}
		$family = KelvinIndividual->new_from_count ($dataset, $pedid, $$state{traits}, $$state{revlabelmap}, [$geno, unmap_traits ($dataset, $traits), $sex]);
		$family->write;
	    } else {
		# Nuclear ped
		$va = 0;
		@individuals = ();
		while (length ($key) > 0) {
		    if ($$state{imprinting} || $$state{xchr}) {
			$key =~ s/^(..)(.{$n})(.)//;
			($geno, $traits, $sex) = ($1, $2, $3);
			$sex = ($sex eq 'm') ? 1 : 2;
		    } else {
			$key =~ s/^(..)(.{$n})//;
			($geno, $traits, $sex) = ($1, $2, ($va++ % 2) + 1);
		    }
		    push (@individuals, [$geno, unmap_traits ($dataset, $traits), $sex]);
		}
		$family = KelvinFamily->new_from_count ($dataset, $pedid, $$state{traits}, $$state{revlabelmap}, \@individuals);
		$family->write;
	    }
	}
	push (@{$$state{kelvinargs}}, "--CountFile", $$state{countfile});
    }

    # Free up most of the memory held by count-related data structures
    $$state{counts} = $$state{markers} = $$state{pedlabels} = 
	$$state{traits} = $$state{uncountedpeds} = undef;
    return;
}

sub by_len
{
    my ($a, $b) = @_;
    my $ret;

    (($ret = (length ($a) <=> length ($b))) != 0)
	and return ($ret);
    return ($a cmp $b);
}

sub get_allele_mapping
{
    my ($state, $idx, $aref) = @_;
    my ($a1, $a2);
    my $va;

    
    if (! defined ($$state{labelmap}[$idx])) {
	$$state{labelmap}[$idx] = { 0 => 0 };
	$$state{revlabelmap}[$idx] = { 0 => 0 };
    }
    if (scalar (@$aref) == 1) {
	# Not particularly efficient.
	($a1, $a2) = ($$aref[0], $$aref[0]);
    } else {
	($a1, $a2) = ($$aref[0] le $$aref[1]) ? (@$aref[0,1]) : (@$aref[1,0]);
    }
    $va = scalar (keys (%{$$state{labelmap}[$idx]}));
    map {
	if (! exists ($$state{labelmap}[$idx]{$_})) {
	    $$state{labelmap}[$idx]{$_} = $va;
	    $$state{revlabelmap}[$idx]{$va++} = $_;
	}
    } ($a1, $a2);
    @$aref = @{$$state{labelmap}[$idx]}{($a1, $a2)};
    return (1);
}


sub get_trait_mapping
{
    my ($individual, $trait) = @_;
    my $val = $individual->getTrait ($trait);
    my $flag = $ {$individual->dataset->getTrait ($trait)}{flag};

    ($flag eq 'C') and return ($val);
    (! exists ($phenomap{$val}))
	and error ("illegal phenotype for family ". $individual->pedid. ", individual ". $individual->indid);
    return ($phenomap{$val});
}


sub unmap_traits
{
    my ($dataset, $traits) = @_;
    my $trait;
    my $aref = [];
    my $va = 0;

    foreach $trait (@{$dataset->traitOrder}) {
	if ($ {$dataset->getTrait ($trait)}{flag} eq 'C') {
	    push (@$aref, substr ($traits, $va++, 1));
	} else {
	    push (@$aref, $phenocodes{substr ($traits, $va++, 1)});
	}
    }
    return ($aref);
}


#
# If epistasis is called for, figure out how many passes we need to make,
# and set up data structures and temporary files. 
#
sub setup_epistasis
{
    my ($state, $config, $dataset, $countstate) = @_;
    my ($epimarker, $epidataset);
    my $family;
    my $individual;
    my %allele_map = ('0' => '0');
    my $indgenos = {};
    my $maps = [];
    my $conffiles = {};
    my $classes;
    my $href = {};
    my $aref = [];
    my $geno;
    my $pass;
    my $va;

    ($aref = $config->isConfigured ("Epistasis"))
	or return;
    $epimarker = $$aref[0];
    ($SEQUPDATE_BINARY =~ /no_sequpdate_binary/i)
	and error ("can't run Epistasis, no sequpdate binary found");
    ($aref = $dataset->traitOrder)
	or error ("can't run Epistasis on a dataset with no trait");
    $$state{trait} = $$aref[0];
    ($config->isConfigured ("SexLinked")) and $$state{xchr} = 1;
    ($config->isConfigured ("LD")) and $$state{ld} = 1;
    ($config->isConfigured ("Multipoint")) and $$state{multipoint} = 1;
    ($config->isConfigured ("ExtraMODs")) and $$state{extramods} = 1;
    $$conffiles{pedigreefile} = $ {$config->isConfigured ("EpistasisPedigreeFile")}[0];
    $$conffiles{locusfile} = $ {$config->isConfigured ("EpistasisLocusFile")}[0];
    ($aref = $config->isConfigured ("EpistasisFrequencyFile"))
	and $$conffiles{freqfile} = $$aref[0];
    $epidataset = KelvinDataset->new ($conffiles)
	or error ("KelvinDataset new failed, $KelvinDataset::errstr");
    if ($epidataset->freqread) {
	$va = 1;
	map { 
	    $allele_map{$_} = $va++;
	} sort ({$a cmp $b} keys %{$epidataset->getAlleleFreqs ($epimarker)});
	(scalar (keys (%allele_map)) > 3)
	    and error ("Epistasis marker '$epimarker' has more than two alleles");
    } else {
	@allele_map{(1,2)} = (1, 2);
    }
    while ($family = $epidataset->readFamily) {
	foreach $individual (@{$family->individuals}) {
	    ($aref = $individual->getGenotype ($epimarker))
		or error ("KelvinIndividual getGenotype failed, $KelvinIndividual::errstr");
	    $geno = join ('_', sort (map { $allele_map{$_} } @$aref));
	    $$indgenos{"P".$individual->pedid."I".$individual->indid} = $geno;
	    (exists ($$href{$geno})) or $$href{$geno} = '';
	}
    }
    (defined ($family))
	or error ("KelvinDataset readFamily failed, $KelvinDataset::errstr");
    $epidataset->close;
    $$state{indgenos} = $indgenos;
    (($classes = epistasis_LC_map ($$state{ld}, $maps, $href)) <= 1)
	and return;
    $config->addDirective ("LiabilityClasses", $classes);
    
    $$conffiles{pedigreefile} = $ {$config->isConfigured ("PedigreeFile")}[0];
    $$conffiles{locusfile} = $ {$config->isConfigured ("LocusFile")}[0];
    $$conffiles{bayesratiofile} = $ {$config->isConfigured ("BayesRatioFile")}[0];
    ($aref = $config->isConfigured ("MODFile")) and $$conffiles{modfile} = $$aref[0];
    if ($$state{multipoint}) {
	$$state{sequpdateargs} = ['-e', '-m', '-R', $$conffiles{bayesratiofile}];
    } else {
	$$conffiles{pplfile} = $ {$config->isConfigured ("PPLFile")}[0];
	$$state{sequpdateargs} = ['-e', '-O', $$conffiles{bayesratiofile}, '-R',
				  $$conffiles{pplfile}];
    }
    $$conffiles{configfile} = $config->filename;

    $$state{passes} = scalar (@$maps);
    for ($va = 0; $va < $$state{passes}; $va++) {
	$pass = $$state{"pass$va"} = {};
	$$pass{map} = $$maps[$va];
	$$pass{classes} = $classes;
	$$pass{dataset} = $dataset->copy ({purge => [$epimarker]});
	$$pass{kelvinargs} = [];
	map {
	    if (exists ($$conffiles{$_})) {
		$$pass{files}{$_} = $$conffiles{$_}. ".pass$va";
		push (@{$$pass{kelvinargs}}, "--$_", $$pass{files}{$_});
	    }
	} qw/pedigreefile locusfile bayesratiofile modfile/;
	$$pass{files}{configfile} = $$conffiles{configfile}. ".pass$va";
	push (@{$$state{sequpdateargs}}, $$pass{files}{bayesratiofile});

	$$pass{dataset}->addTrait ('EpistasisClass', 'C', 'end');
	$$pass{dataset}->write ({pedigreefile => $$pass{files}{pedigreefile},
				 locusfile => $$pass{files}{locusfile}})
	    or error ("KelvinDataset write failed, $KelvinDataset::errstr");
	if ($$pass{countstate}{countable} = $$countstate{countable}) {
	    map { $$pass{countstate}{$_} = $$countstate{$_} } keys (%$countstate);
	    setup_pedcount ($$pass{countstate}, $config, $$pass{dataset});
	}
    }
    $$state{conffiles} = $conffiles;
    return;
}

sub epistasis_family
{
    my ($state, $family) = @_;
    my $epifamily;
    my $individual;
    my $pass;
    my $id;
    my $va;

    for ($va = 0; $va < $$state{passes}; $va++) {
	$pass = $$state{"pass$va"};
	$epifamily = $family->map ($$pass{dataset});
	foreach $individual (@{$epifamily->individuals}) {
	    $id = "P". $individual->pedid. "I". $individual->indid;
	    if (exists ($$pass{map}{$$state{indgenos}{$id}})) {
		$individual->setTrait ("EpistasisClass", $$pass{map}{$$state{indgenos}{$id}});
	    } else {
		$individual->setTrait ($$state{trait}, $phenocodes{$UNDEFINED});
		$individual->setTrait ("EpistasisClass", 1);
	    }
	}
	($$pass{countstate}{countable}) 
	    and count_family ($$pass{countstate}, $epifamily);
	$epifamily->write;
    }
}

sub run_epistasis
{
    my ($state, $freqstate, $config, $microsats) = @_;
    my $pass;
    my $ret;
    my $va;

    # Write counted pedigrees for each pass first (if applicable), since this also frees
    # up memory that we can use for running Kelvin
    for ($va = 0; $va < $$state{passes}; $va++) {
	$pass = $$state{"pass$va"};
	$$pass{dataset}->set_microsats ($microsats);
	($$pass{countstate}{countable})
	    and write_pedcount ($$pass{countstate}, $$pass{dataset});
    }
    if ($config->isConfigured ("SkipAnalysis")) {
	warner ("Skipping analysis\n");
	return;
    }
    
    for ($va = 0; $va < $$state{passes}; $va++) {
	$pass = $$state{"pass$va"};
	$config->write ({configfile => $$pass{files}{configfile}, nolocal => 1});
	(($ret = system ($KELVIN_BINARY, $$pass{files}{configfile}, @ARGV, @{$$freqstate{kelvinargs}}, @{$$pass{kelvinargs}}, @{$$pass{countstate}{kelvinargs}})) != 0)
	    and error ("$KELVIN_BINARY failed, ", ($ret == -1) ? "$!" : "status $?");
    }
    
    if ($$state{passes} == 1) {
	map {
	    exists ($$state{pass0}{files}{$_})
		and rename ($$state{pass0}{files}{$_}, $$state{conffiles}{$_});
	} qw/bayesratiofile modfile/;
	($$state{pass0}{countstate}{countable})
	    and remove ($$state{pass0}{countstate}{countfile});
    } else {
	# calc_updated_ppl will barf if one of its output files already exists
	exists ($$state{conffiles}{pplfile}) and remove ($$state{conffiles}{pplfile});
	(($ret = system ($SEQUPDATE_BINARY, @{$$state{sequpdateargs}})) != 0)
	    and error ("$SEQUPDATE_BINARY failed, ", ($ret == -1) ? "$!" : "status $?");
	if (exists ($$state{conffiles}{modfile})) {
	    if (! $$state{multipoint}) {
		epistasis_merge_TP_mod ($state);
	    } else {
		epistasis_merge_MP_mod ($state);
	    }
	}
    }

    for ($va = 0; $va < $$state{passes}; $va++) {
	$pass = $$state{"pass$va"};
	# A shotgun approach here: some of these files may not have been created
	map {
	    exists ($$pass{files}{$_}) and remove ($$pass{files}{$_});
	} qw/pedigreefile locusfile bayesratiofile modfile configfile/;
	($$pass{countstate}{countable})
	    and remove (@{$$pass{countstate}}{qw/pedigreefile countfile/});
    }
    return;
}

# This will need to be significantly retooled if we ever move to multi-marker 
# epistasis. For the moment, we assume a single SNP. We need to provide three
# pieces of information to the epistasis routine: the number of liability classes,
# the number of Kelvin runs, and a mapping of genotypes to liability class for
# each Kelvin run. We load the pass-by-reference array with one genotype-to-LC
# map for each kelvin run, and return the number of liability classes directly.
sub epistasis_LC_map
{
    my ($ld, $aref, $genos) = @_;
    my $href = {};
    my $count = 0;
    my $geno;

    foreach (qw/1_1 1_2 2_2/) {
        if (exists ($$genos{$_})) {
            $$href{$_} = ++$count;
        } else {
            ($geno = $_) =~ s/_/,/;
            warner ("no individuals in pedigree with $geno genotype at epistasis marker");
        }
    }
    # All individuals have the same genotype at the epistasis locus. No point running
    # with liability classes at all.
    if ($count <= 1) {
        warner ("Epistasis analysis disabled due to limited observed genotypes.");
	return (1);
    }
    # One or more genotypes were not observed at the epistasis locus (so long as we
    # only handle SNPs, $count should be exactly 2 in this case). We'll do one pass
    # with $count liability classes, with the mapping set according to the genotypes
    # that were observed.
    if ($count != 3) {
        warner ("Epistasis analysis limited due to limited observed genotypes.");
        @$aref = ($href);
        return ($count);
    }

    # Once upon a time (in r3506), LD epistasis analyses were handled as a single
    # 3LC run. Now LD is handled like LE, as two 2LC runs, and we'll merge the results.
    @$aref = ({'1_1', => 1, '1_2' => 1, '2_2' => 2},
	      {'1_1', => 1, '1_2' => 2, '2_2' => 2});
    return (2);
}

# Assumes epistasis with a single SNP, which implies only two MOD files to merge.
sub epistasis_merge_TP_mod
{
    my ($state) = @_;
    my $modfile = $$state{conffiles}{modfile};
    my $modpass0 = $$state{pass0}{files}{modfile};
    my $modpass1 = $$state{pass1}{files}{modfile};
    my ($fh0, $fh1, $outfh);
    my (@flds0, @flds1);
    my ($pen1, $pen2);
    my $line;
    my $modidx = ($$state{extramods}) ? 1 : 0;
    my $extralines = 0;
    my $va;

    # If extramods if turned on, there will be one (or four, if LD is also on) 
    # extra MOD lines for each marker. If extramods is off, there are no extras
    # lines, regardless of LD.
    $extralines = (($$state{extramods}) ? 1 : 0);
    ($extralines && $$state{ld}) and $extralines += 3;

    $outfh = IO::File->new (">$modfile") or error ("open '$modfile' failed, $!\n");
    $fh0 = IO::File->new ($modpass0) or error ("open '$modpass0' failed, $!\n");
    $fh1 = IO::File->new ($modpass1) or error ("open '$modpass1' failed, $!\n");

    # Version line
    $outfh->print ($fh0->getline);
    $fh1->getline;

    while ($line = $fh0->getline) {
        # Marker line
        $outfh->print ($line);
        $fh1->getline;

        # Header line
        ($line = $fh0->getline) =~ s/LC2PV(\([Dd,]+\))$/LC2PV$1 LC3PV$1/;
        $outfh->print ($line);
        $fh1->getline;

        # Overall MOD line
        @flds0 = split (/\s+/, $fh0->getline);
        @flds1 = split (/\s+/, $fh1->getline);

        if ($flds0[$modidx] >= $flds1[$modidx]) {
            ($pen1, $pen2) = splice (@flds0, -2, 2);
            $outfh->print (join (' ', @flds0, $pen1, $pen1, $pen2), "\n");
	    for ($va = 0; $va < $extralines; $va++) {
                @flds0 = split (/\s+/, $fh0->getline);
                ($pen1, $pen2) = splice (@flds0, -2, 2);
                $outfh->print (join (' ', @flds0, $pen1, $pen1, $pen2), "\n");
                $fh1->getline;
            }
        } else {
            ($pen1, $pen2) = splice (@flds1, -2, 2);
            $outfh->print (join (' ', @flds1, $pen1, $pen2, $pen2), "\n");
	    for ($va = 0; $va < $extralines; $va++) {
                @flds1 = split (/\s+/, $fh1->getline);
                ($pen1, $pen2) = splice (@flds1, -2, 2);
                $outfh->print (join (' ', @flds1, $pen1, $pen2, $pen2), "\n");
                $fh0->getline;
            }
        }
    }
    $outfh->close;
    $fh0->close;
    $fh1->close;
    return (1);
}

# Assumes epistasis with a single SNP, which implies only two MOD files to merge.
sub epistasis_merge_MP_mod
{
    my ($state) = @_;
    my $modfile = $$state{conffiles}{modfile};
    my $modpass0 = $$state{pass0}{files}{modfile};
    my $modpass1 = $$state{pass1}{files}{modfile};
    my ($fh0, $fh1, $outfh);
    my (@flds0, @flds1);
    my ($pen1, $pen2);
    my $line;
    my $modidx = 0;

    $outfh = IO::File->new (">$modfile") or error ("open '$modfile' failed, $!\n");
    $fh0 = IO::File->new ($modpass0) or error ("open '$modpass0' failed, $!\n");
    $fh1 = IO::File->new ($modpass1) or error ("open '$modpass1' failed, $!\n");

    # Version line
    $outfh->print ($fh0->getline);
    $fh1->getline;

    # Header line
    ($line = $fh0->getline) =~ s/LC2PV(\([Dd,]+\))$/LC2PV$1 LC3PV$1/;
    @flds0 = split (/\s+/, $line);
    while ($flds0[$modidx] !~ /MOD/i) {
	$modidx++;
    }
    $outfh->print ($line);
    $fh1->getline;

    while ($line = $fh0->getline) {
        @flds0 = split (/\s+/, $line);
        @flds1 = split (/\s+/, $fh1->getline);

        if ($flds0[$modidx] >= $flds1[$modidx]) {
            ($pen1, $pen2) = splice (@flds0, -2, 2);
            $outfh->print (join (' ', @flds0, $pen1, $pen1, $pen2), "\n");
        } else {
            ($pen1, $pen2) = splice (@flds1, -2, 2);
            $outfh->print (join (' ', @flds1, $pen1, $pen2, $pen2), "\n");
        }
    }
    $outfh->close;
    $fh0->close;
    $fh1->close;
    return (1);
}

#
# Validate conditions for allele frequency estimation, and set up data
# structures, if appropriate.
#
sub setup_frequency_estimation
{
    my ($state, $config, $dataset) = @_;
    my $aref;
    
    ($config->isConfigured ("SexLinked"))
	and $$state{xchr} = 1;
    ($aref = $dataset->traitOrder)
	and $$state{trait} = $$aref[0];
    if ($config->isConfigured ("QT") || $config->isConfigured ("QTT")) {
	$$state{qt} = 1;
	$$state{prevalence} = 0;
    } else {
	($aref = $config->isConfigured ("TraitPrevalence"))
	    and $$state{prevalence} = $$aref[0];
    }
    
    if ($config->isConfigured ("SkipEstimation")) {
	warner ("Automatic allele frequency estimation is disabled by directive");
	$$state{estimate} = 0;
    } elsif (! $config->isConfigured ("LD") && ! $config->isConfigured ("SkipAnalysis")) {
	warner ("Automatic allele frequency estimation is disabled for linkage analysis");
	$$state{estimate} = 0;
    } elsif ($dataset->microsats) {
	warner ("Automatic allele frequency estimation is disabled, microsatellites detected");
	$$state{estimate} = 0;
    } elsif (! defined ($$state{trait})) {
	warner ("Automatic allele frequency estimation is disabled, no trait in dataset");
	$$state{estimate} = 0;
    }
    ($$state{estimate}) or return;
    warner ("Automatic allele frequency estimation is enabled (use SkipEstimation to disable)");
    $$state{markers} = $dataset->markerOrder;
    map { $$state{cases}{$_} = {count => 0, alleles => {}} } @{$$state{markers}};
    map { $$state{controls}{$_} = {count => 0, alleles => {}} } @{$$state{markers}};
    map { $$state{nuclear}{$_} = {count => 0, alleles => {}} } @{$$state{markers}};
    map { $$state{freqs}{$_} = {} } @{$$state{markers}};
    return;
}

#
# Process a family for allele frequency estimation.
#
sub count_alleles
{
    my ($state, $family) = @_;
    my $marker;
    my ($dad, $mom, $kid);
    my ($dadgeno, $momgeno, $kidgeno);
    my (%nonxmit, $kidcount);
    my $dadcontrib;
    my $sex;
    my $aref;
    my $va;

    if ($family->pedtype eq 'general') {
	warner ("Automatic allele frequency estimation is disabled, general pedigrees detected");
	@$state{qw/cases controls nuclear/} = (undef, undef, undef);
	$$state{estimate} = 0;
	return;
    }

    if ($family->pedtype eq 'casecontrol') {
	$kid = $ {$family->children}[0];
	($kid->genotyped) or return;
	$sex = $kid->sex;
	foreach $marker (@{$$state{markers}}) {
	    $kidgeno = $kid->getGenotype ($marker);
	    ($$kidgeno[0] eq '0') and next;
	    # Only count one of the homozygous alleles for males on chr X
	    ($$state{xchr} && $sex eq '1') and shift (@$kidgeno);
	    # For QT/QTT, everyone is coded as a control (unaffected)
	    if ($$state{qt} || $kid->getTrait ($$state{trait}) ne $phenocodes{$AFFECTED}) {
		map {
		    exists ($$state{controls}{$marker}{alleles}{$_})
			or $$state{controls}{$marker}{alleles}{$_} = 0;
		    $$state{controls}{$marker}{alleles}{$_}++;
		} @$kidgeno;
		$$state{controls}{$marker}{count}++;
	    } else {
		map {
		    exists ($$state{cases}{$marker}{alleles}{$_})
			or $$state{cases}{$marker}{alleles}{$_} = 0;
		    $$state{cases}{$marker}{alleles}{$_}++;
		} @$kidgeno;
		$$state{cases}{$marker}{count}++;
	    }
	}
    } else {
	$aref = $family->individuals;
	# This assumes a post-makeped pedigree ordering (founders first)
	if ($$aref[0]->sex eq '1') {
	    ($dad, $mom) = splice (@$aref, 0, 2);
	} else {
	    ($mom, $dad) = splice (@$aref, 0, 2);
	}
	($dad->genotyped && $mom->genotyped) or return;
	$va = 0;
	if ($$state{qt}) {
	    # QT or QTT, we only count alleles in founders
	    foreach $marker (@{$$state{markers}}) {
		$momgeno = $mom->getGenotype ($marker);
		$dadgeno = $dad->getGenotype ($marker);
		($$state{xchr}) and shift (@$dadgeno);
		if ($$momgeno[0] eq '0') {
		    ($$dadgeno[0] eq '0') and next;
		    @$momgeno = ();
		} elsif ($$dadgeno[0] ne '0') {
		    push (@$momgeno, @$dadgeno);
		}
		map {
		    exists ($$state{nuclear}{$marker}{alleles}{$_})
			or $$state{nuclear}{$marker}{alleles}{$_} = 0;
		    $$state{nuclear}{$marker}{alleles}{$_}++;
		} @$momgeno;
		$$state{nuclear}{$marker}{count}++;
	    }
	} else {
	    # DT, we count alleles NOT transmitted to affected kids only
	    $va = 0;
	    while ($va < scalar (@$aref)) {
		if ((! $$aref[$va]->genotyped) ||
		    $$aref[$va]->getTrait ($$state{trait}) ne $phenocodes{$AFFECTED}) {
		    splice (@$aref, $va, 1);
		} else {
		    $va++;
		}
	    }
	    (scalar (@$aref)) or return;
	    #print (join (',', ("mom", $mom->pedid, $mom->indid, "dad", $dad->pedid, $dad->indid, scalar (@$aref), "kids")), "\n");
	    foreach $marker (@{$$state{markers}}) {
		%nonxmit = ();
		$momgeno = $mom->getGenotype ($marker);
		$dadgeno = $dad->getGenotype ($marker);
		#print ("($$momgeno[0],$$momgeno[1]) ($$dadgeno[0],$$dadgeno[1]) ");
		($$momgeno[0] eq '0' || $$dadgeno[0] eq '0') and next;
		($$state{xchr}) and shift (@$dadgeno);
		map { $nonxmit{$_} = 0; } (@$momgeno, @$dadgeno);
		#print (join (', ', map { "$_ => $nonxmit{$_}" } keys (%nonxmit)), "   ");
		$kidcount = 0;
		foreach $kid (@$aref) {
		    $kidgeno = $kid->getGenotype ($marker);
		    ($$kidgeno[0] eq '0') and next;
		    #print ("($$kidgeno[0],$$kidgeno[1]) ");
		    map { $nonxmit{$_}++ } @$momgeno;
		    if ($$state{xchr}) {
			if ($kid->sex eq '1') {
			    shift (@$kidgeno);
			    $nonxmit{$$dadgeno[0]} += 0.5;
			} else {
			    $nonxmit{$$dadgeno[0]} += 1.5;
			}
		    } else {
			map { $nonxmit{$_}++; } @$dadgeno;
		    }
		    map { $nonxmit{$_}--; } @$kidgeno;
		    $kidcount++;
		}
		($kidcount > 0) or next;
		#print (join (', ', map { "$_ => $nonxmit{$_}" } keys (%nonxmit)), "\n");
		map {
		    $$state{nuclear}{$marker}{alleles}{$_} += $nonxmit{$_} / $kidcount;
		} keys (%nonxmit);
		$$state{nuclear}{$marker}{count}++;
	    }
	}
    }
    return;
}

#
# Calculate allele frequcies based on pedigree allele counts
#
sub finish_frequency_estimation
{
    my ($state, $dataset) = @_;
    my $marker;
    my ($count_case, $count_ctrl, $count_nuc);
    my ($case, $control, $nuc) = (0, 0, 0);
    my ($one, $two);
    my $freq;
    my %hash;
    my @arr;

    foreach $marker (@{$$state{markers}}) {
	$count_case = $$state{cases}{$marker}{count};
	$count_ctrl = $$state{controls}{$marker}{count};
	$count_nuc = $$state{nuclear}{$marker}{count};
	if ($count_ctrl + $count_nuc < 30) {
	    warner ("Automatic allele frequency estimation is disabled, too few useful families for marker $marker");
	    $$state{estimate} = 0;
	    return;
	}
	%hash = ();
	map {
	    $hash{$_} = '';
	} (keys (%{$$state{cases}{$marker}{alleles}}),
	   keys (%{$$state{controls}{$marker}{alleles}}),
	   keys (%{$$state{nuclear}{$marker}{alleles}}));
	if (scalar (@arr = sort (keys (%hash))) > 2) {
	    warner ("Automatic allele frequency estimation is disabled, marker $marker is a microsatellite");
	    $$state{estimate} = 0;
	    return;
	} elsif (scalar (@arr) == 1) {
	    $$state{freqs}{$marker}{$arr[0]} = "1.0000";
	} else {
	    #print ("marker $marker alleles ($arr[0],$arr[1]): ");
	    if ($count_case > 0) {
		($one, $two) = @{$$state{cases}{$marker}{alleles}}{@arr};
		#print ("$count_case cases ($one, $two), ");
		$case = (! defined ($one)) ? 0 : ((! defined ($two)) ? 1 : $one / ($one + $two));
	    }
	    if ($count_ctrl > 0) {
		($one, $two) = @{$$state{controls}{$marker}{alleles}}{@arr};
		#print ("$count_ctrl controls ($one, $two), ");
		$control = (! defined ($one)) ? 0 : ((! defined ($two)) ? 1 : $one / ($one + $two));
	    }
	    if ($count_nuc > 0) {
		($one, $two) = @{$$state{nuclear}{$marker}{alleles}}{@arr};
		#print ("$count_nuc nucs ($one, $two), ");
		$nuc = (! defined ($one)) ? 0 : ((! defined ($two)) ? 1 : $one / ($one + $two));
	    }
	    #print ("prev $$state{prevalence}, ");
	    $freq = $$state{prevalence} * $case + (1 - $$state{prevalence}) * $control;
	    #printf ("freq %.04f, ", $freq);
	    $freq = ($freq * $count_ctrl + $nuc * $count_nuc) / ($count_ctrl + $count_nuc);
	    #printf ("freq %.04f\n", $freq);
	    $$state{freqs}{$marker}{$arr[0]} = sprintf ("%.04f", $freq);
	    $$state{freqs}{$marker}{$arr[1]} = sprintf ("%.04f", 1 - $$state{freqs}{$marker}{$arr[0]});
	}
    }

    foreach $marker (@{$$state{markers}}) {
	    $dataset->setAlleleFreqs ($marker, $$state{freqs}{$marker});
    }
    $dataset->writeFreqfile ("kelvin.freq") or die ("writeFreqfile failed, $KelvinDataset::errstr\n");
    @{$$state{kelvinargs}} = ( "--FrequencyFile", "kelvin.freq" );
    return;
}


BEGIN {
    %equivalentkeys =
	(
	 '_N000000111' => '_C111', # Cases/controls with fake parents
	 '_N000000112' => '_C112',
	 '_N000000121' => '_C121',
	 '_N000000122' => '_C122',
	 '_N000000221' => '_C221',
	 '_N000000222' => '_C222',
	 
	 '_N000m000f111m' => '_C111m', # Cases/Controls with fake parents, for X-Chr
	 '_N000m000f112m' => '_C112m',
	 '_N000m000f221m' => '_C221m',
	 '_N000m000f222m' => '_C222m',
	 '_N000m000f111f' => '_C111f',
	 '_N000m000f112f' => '_C112f',
	 '_N000m000f121f' => '_C121f',
	 '_N000m000f122f' => '_C122f',
	 '_N000m000f221f' => '_C221f',
	 '_N000m000f222f' => '_C222f',
	 );

    %keylabels = 
	(
	 '_C111' => 'ctrl11', # Bare cases/controls
	 '_C112' => 'case11',
	 '_C121' => 'ctrl12',
	 '_C122' => 'case12',
	 '_C221' => 'ctrl22',
	 '_C222' => 'case22',
	 
	 '_C111m' => 'ctrl1', # Bare cases/controls for X-Chr
	 '_C112m' => 'case1',
	 '_C221m' => 'ctrl2',
	 '_C222m' => 'case2',
	 '_C111f' => 'ctrl11',
	 '_C112f' => 'case11',
	 '_C121f' => 'ctrl12',
	 '_C122f' => 'case12',
	 '_C221f' => 'ctrl22',
	 '_C222f' => 'case22',
	 
	 '_N000000111' => 'ctrl11', # Cases/controls with fake parents, map to the same labels
	 '_N000000112' => 'case11',
	 '_N000000121' => 'ctrl12',
	 '_N000000122' => 'case12',
	 '_N000000221' => 'ctrl22',
	 '_N000000222' => 'case22',
	 
	 '_N000m000f111m' => 'ctrl1', # Cases/Controls with fake parents, for X-Chr
	 '_N000m000f112m' => 'case1',
	 '_N000m000f221m' => 'ctrl2',
	 '_N000m000f222m' => 'case2',
	 '_N000m000f111f' => 'ctrl11',
	 '_N000m000f112f' => 'case11',
	 '_N000m000f121f' => 'ctrl12',
	 '_N000m000f122f' => 'case12',
	 '_N000m000f221f' => 'ctrl22',
	 '_N000m000f222f' => 'case22',
	 
	 '_N001001002' => 'T30', # Historical coding for strict trios
	 '_N001001112' => 'T18',
	 '_N001001122' => 'T19',
	 '_N001001222' => 'T20',
	 '_N001111002' => 'T24',
	 '_N001111112' => 'T05',
	 '_N001111122' => 'T06',
	 '_N001121002' => 'T27',
	 '_N001121112' => 'T12',
	 '_N001121122' => 'T13',
	 '_N001121222' => 'T14',
	 '_N001221002' => 'T29',
	 '_N001221122' => 'T16',
	 '_N001221222' => 'T17',
	 '_N111111002' => 'T21',
	 '_N111111112' => 'T01',
	 '_N111121002' => 'T22',
	 '_N111121112' => 'T02',
	 '_N111121122' => 'T03',
	 '_N111221002' => 'T23',
	 '_N111221122' => 'T04',
	 '_N121121002' => 'T25',
	 '_N121121112' => 'T07',
	 '_N121121122' => 'T08',
	 '_N121121222' => 'T09',
	 '_N121221002' => 'T26',
	 '_N121221122' => 'T10',
	 '_N121221222' => 'T11',
	 '_N221221002' => 'T28',
	 '_N221221222' => 'T15'
	 );
}

sub equivalentkey
{
    my ($key) = @_;

    return (exists ($equivalentkeys{$key}) ? ($equivalentkeys{$key}) : $key);
}

sub keylabel
{
    my ($key) = @_;

    return (exists ($keylabels{$key}) ? $keylabels{$key} : $key);
}

#
# Check the paths to the executables and scripts we need to get work done.
#
sub check_paths
{
    # For all of these, we allow environment variables to override everything,
    # even if values were set during installation.
    if ($ENV{KELVIN_ROOT}) {
	($KELVIN_ROOT !~ /no_kelvin_root/i)
	    and warner ("overriding installed KELVIN_ROOT with '$ENV{KELVIN_ROOT}' from environment");
	$KELVIN_ROOT = $ENV{KELVIN_ROOT};
    } elsif ($KELVIN_ROOT =~ /no_kelvin_root/i) {
	$KELVIN_ROOT = dirname ($0);
	warner ("no KELVIN_ROOT defined by installation, using '$KELVIN_ROOT'");
    }
    
    # Instead of 'use'ing our support modules up above, we 'require' them now,
    # after we've had a chance to add KELVIN_ROOT to @INC.
    unshift (@INC, $KELVIN_ROOT);
    require KelvinDataset;
    require KelvinConfig;
    require KelvinFamily;
    # Check versions ('use' would have done for us automatically)
    KelvinDataset->VERSION (1.40);
    KelvinConfig->VERSION (1.40);
    KelvinFamily->VERSION (1.50);

    if ($ENV{KELVIN_BINARY}) {
	($KELVIN_BINARY !~ /no_kelvin_binary/i)
	    and warner ("overriding installed KELVIN_BINARY with '$ENV{KELVIN_BINARY}' from environment");
	$KELVIN_BINARY = $ENV{KELVIN_BINARY};
    } elsif ($KELVIN_BINARY =~ /no_kelvin_binary/i) {
	if (defined ($KELVIN_BINARY = find_versioned_kelvin ($KELVIN_ROOT)) && -x $KELVIN_BINARY) {
	    warner ("no KELVIN_BINARY defined by installation, using '$KELVIN_BINARY'");
	} elsif (-x ($KELVIN_BINARY = "$KELVIN_ROOT/kelvin.$platform")) {
	    warner ("no KELVIN_BINARY defined by installation, using '$KELVIN_BINARY'");
	} elsif (-x ($KELVIN_BINARY = "$KELVIN_ROOT/bin/kelvin.$platform")) {
	    warner ("no KELVIN_BINARY defined by installation, using '$KELVIN_BINARY'");
	} else {
	    error ("no kelvin binary (kelvin-x.y.z or kelvin.$platform) found under $KELVIN_ROOT");
	}
    }
    
    if ($ENV{SEQUPDATE_BINARY}) {
	($SEQUPDATE_BINARY !~ /no_sequpdate_binary/i)
	    and warner ("overriding installed SEQUPDATE_BINARY with '$ENV{SEQUPDATE_BINARY}' from environment");
	$SEQUPDATE_BINARY = $ENV{SEQUPDATE_BINARY};
    } elsif ($SEQUPDATE_BINARY =~ /no_sequpdate_binary/i) {
	if (-x ($SEQUPDATE_BINARY = "$KELVIN_ROOT/calc_updated_ppl")) {
	    warner ("no SEQUPDATE_BINARY defined by installation, using '$SEQUPDATE_BINARY'");
	} elsif (-x ($SEQUPDATE_BINARY = "$KELVIN_ROOT/seq_update/calc_updated_ppl")) {
	    warner ("no SEQUPDATE_BINARY defined by installation, using '$SEQUPDATE_BINARY'");
	} else {
	    $SEQUPDATE_BINARY = 'no_sequpdate_binary';
	}
    }
    
    return;
}

sub platform_name
{
    my $platform;

    $platform = `uname -m`;
    $platform .= '-' . `uname -s`;
    $platform =~ tr/ \n/-/d;
    return ($platform);
}

sub find_versioned_kelvin
{
    my ($dir) = @_;
    my $file;
    my @arr;

    # Look in the directory that we were passed (prolly KELVIN_ROOT)
    opendir (DIRH, $dir) or error ("opendir '$dir' failed, $!");
    while ($file = readdir (DIRH)) {
	$file =~ /^kelvin-\d+\.\d+(?:\.\d+)$/ or next;
	(-x "$dir/$file") or next;
	push (@arr, $file);
    }
    if (! scalar (@arr)) {
	# Nobody home? See if there's a bin subdirectory, and if so, look there
	(-d "$dir/bin" && ($file = find_versioned_kelvin ("$dir/bin")))
	    and return ($file);
	return (undef);
    }
    @arr = reverse (sort (@arr));
    return ("$dir/$arr[0]");
}

sub fatal
{
    die ("FATAL - ABORTING, @_");
}

sub error
{
    die ("ERROR - EXITING, @_\n");
}

sub warner
{
    warn ("WARNING, @_\n");
}


# Structures of the state hashs used for pedcounting, epistasis and frequency estimation
# countState = {
#   cleanup => boolean,
#   countable => boolean,
#   countfile => scalar,
#   imprinting => boolean,
#   pedigreefile => scalar,
#   xchr => boolean,
#   precounted => int,
#   postcounted => int,
#   counts => [ { pedstructlabel => count,
#                 ...
#               },
#               { pedstructlabel => count,
#                 ...
#               }
#               ...
#             ],
#   kelvinargs => [ ... ],
#   markers => [ markername,
#                ...
#              ],
#   pedlabels => { pedstructlabel => '',
#                  ...
#                }
#   traits => [ traitname,
#               ...
#             ],
#   uncountedpeds => [ KelvinFamily,
#                      ...
#                    ]
# }
# 
# epiState = {
#   passes => int,
#   extramods => boolean,
#   ld => boolean,
#   multipoint => boolean,
#   trait => scalar,
#   xchr => boolean,
#   sequpdateargs => [ ... ],
#   conffiles => { 'pedigreefile' => scalar,
#                  'locusfile' => scalar,
#                  'bayesratiofile' => scalar,
#                  'pplfile' => scalar,
#                  'modfile' => scalar
#                }
#   indgenos => { identifier => geno,
#                 ...
#               },
#   pass0 => { classes => scalar,
#              dataset => KelvinDataset,
#              files => { 'pedigreefile' => scalar,
#                         ...
#                       },
#              map => { geno => int,
#                       ...
#                     }
#              countstate => countState
#              kelvinargs => [ ... ],
#            }
#   }
#   
# }
# 
