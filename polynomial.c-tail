#define MAXPOLYTIERS 13
int polyTiers[MAXPOLYTIERS][5];
int peakPolyTiers;
char *polyTypes[] = { "constant", "variable", "sum", "product", "function" };

/* It might not be a sumPoly, but we can treat it as one. */
void
traversePoly (struct polynomial *p, int currentTier)
{
  int i;

  fprintf (stderr, "%d(%d) ", p->id, p->count);
  if (currentTier > peakPolyTiers)
    peakPolyTiers = currentTier;
  if (currentTier >= MAXPOLYTIERS)
    return;
  polyTiers[currentTier][p->eType]++;
  switch (p->eType) {
  case T_CONSTANT:
  case T_VARIABLE:
    break;
  case T_SUM:
    for (i = 0; i < p->e.s->num; i++) {
      traversePoly (p->e.s->sum[i], currentTier + 1);
    }
    break;
  case T_PRODUCT:
    for (i = 0; i < p->e.p->num; i++) {
      traversePoly (p->e.p->product[i], currentTier + 1);
    }
    break;
  case T_FUNCTIONCALL:
    for (i = 0; i < p->e.f->paraNum; i++) {
      traversePoly (p->e.f->para[i], currentTier + 1);
    }
    break;
  case T_FREED:
    fprintf (stderr,
	     "In traversePoly, evil caller is trying to use a polynomial that was freed:\n");
    expTermPrinting (p);
    exit (1);
    break;
  default:
    fprintf (stderr, "In traversePoly, unknown expression type: [%d], exiting!\n",
	     p->eType);
    exit (1);
  }
}
void
printSummaryPoly (struct polynomial *p)
{
  int i, j;

  fprintf (stderr, "Summary of Remains of %d Polynomials (from tree):\n",
	   nodeId);
  memset (polyTiers, 0, sizeof (polyTiers));
  peakPolyTiers = 0;
  traversePoly (p, 0);
  for (i = 0; i <= peakPolyTiers; i++) {
    fprintf (stderr, "Tier %d:", i);
    int firstPrint = 1;

    for (j = 0; j < 5; j++) {
      if (polyTiers[i][j] != 0) {
	if (!firstPrint)
	  fprintf (stderr, ",");
	firstPrint = 0;
	fprintf (stderr, " %d %s", polyTiers[i][j], polyTypes[j]);
	if (polyTiers[i][j] > 1)
	  fprintf (stderr, "s");
      }
    }
    fprintf (stderr, "\n");
  }
  fprintf (stderr, "---\n");
}

void
expPrinting (struct polynomial *p)
{
  int i;

  switch (p->eType) {
  case T_CONSTANT:
    fprintf (stderr, "%G", p->value);
    break;
  case T_VARIABLE:
    if (strlen (p->e.v->vName) == 0)
      fprintf (stderr, "unnamed%d", p->index);
    else
      fprintf (stderr, "%s", p->e.v->vName);
    break;
  case T_SUM:
    if (p->e.s->num > 1)
      fprintf (stderr, "(");
    if (p->e.s->factor[0] != 1)
      fprintf (stderr, "%G*", p->e.s->factor[0]);
    expPrinting (p->e.s->sum[0]);
    for (i = 1; i < p->e.s->num; i++) {
      fprintf (stderr, "+");
      if (p->e.s->factor[i] != 1)
	fprintf (stderr, "%G*", p->e.s->factor[i]);
      expPrinting (p->e.s->sum[i]);
    }
    if (p->e.s->num > 1)
      fprintf (stderr, ")");
    break;
  case T_PRODUCT:
    if (p->e.p->num > 1)
      fprintf (stderr, "(");
    expPrinting (p->e.p->product[0]);
    if (p->e.p->exponent[0] != 1)
      fprintf (stderr, "^%d", p->e.p->exponent[0]);
    for (i = 1; i < p->e.s->num; i++) {
      fprintf (stderr, "*");
      expPrinting (p->e.p->product[i]);
      if (p->e.p->exponent[i] != 1)
	fprintf (stderr, "^%d", p->e.p->exponent[i]);
    }
    if (p->e.p->num > 1)
      fprintf (stderr, ")");
    break;
  case T_FUNCTIONCALL:
    fprintf (stderr, "%s(", p->e.f->name);
    for (i = 0; i < p->e.f->paraNum - 1; i++) {
      expPrinting (p->e.f->para[i]);
      fprintf (stderr, ", ");
    }
    expPrinting (p->e.f->para[p->e.f->paraNum - 1]);
    fprintf (stderr, ")");
    break;
  case T_FREED:
    fprintf (stderr,
	     "[FREED eType=%d id=%d index=%d key=%d count=%d valid=%d]\n",
	     (int) p->value, p->id, p->index, p->key, p->count, p->valid);
  default:
    fprintf (stderr, "In expPrinting, unknown expression type %d, exiting\n",
	     p->eType);
    exit (1);
  }
}

void
expTermPrinting (struct polynomial *p)
{
  int i;

  switch (p->eType) {
  case T_CONSTANT:
    fprintf (stderr, "%G", p->value);
    break;
  case T_VARIABLE:
    if (strlen (p->e.v->vName) == 0)
      fprintf (stderr, "unnamed%d", p->index);
    else
      fprintf (stderr, "%s", p->e.v->vName);
    break;
  case T_SUM:
    fprintf (stderr, "(s%d:", p->index);
    if (p->e.s->factor[0] != 1)
      fprintf (stderr, "%G*", p->e.s->factor[0]);
    expTermPrinting (p->e.s->sum[0]);
    for (i = 1; i < p->e.s->num; i++) {
      fprintf (stderr, "+");
      if (p->e.s->factor[i] != 1)
	fprintf (stderr, "%G*", p->e.s->factor[i]);
      expTermPrinting (p->e.s->sum[i]);
    }
    fprintf (stderr, ")");
    break;
  case T_PRODUCT:
    fprintf (stderr, "(p%d:", p->index);
    expTermPrinting (p->e.p->product[0]);
    if (p->e.p->exponent[0] != 1)
      fprintf (stderr, "^%d", p->e.p->exponent[0]);
    for (i = 1; i < p->e.s->num; i++) {
      fprintf (stderr, "*");
      expTermPrinting (p->e.p->product[i]);
      if (p->e.p->exponent[i] != 1)
	fprintf (stderr, "^%d", p->e.p->exponent[i]);
    }
    fprintf (stderr, ")");
    break;
  case T_FUNCTIONCALL:
    fprintf (stderr, "%s(", p->e.f->name);
    for (i = 0; i < p->e.f->paraNum - 1; i++) {
      expTermPrinting (p->e.f->para[i]);
      fprintf (stderr, ", ");
    }
    expTermPrinting (p->e.f->para[p->e.f->paraNum - 1]);
    fprintf (stderr, ")");
    break;
  case T_FREED:
    fprintf (stderr,
	     "[FREED eType=%d id=%d index=%d key=%d count=%d valid=%d]\n",
	     (int) p->value, p->id, p->index, p->key, p->count, p->valid);
  default:
    fprintf (stderr, "In expTermPrinting, unknown expression type %d, exiting\n",
	     p->eType);
    exit (1);
  }
}

/*
 This function prints out polynomial statistic information.  It is mainly used for 
 performance evaluation and debugging. */
void
polyStatistics ()
{
  long constantSize, variableSize, sumSize, productSize, functionCallSize;
  int sumTerms = 0, productTerms = 0;
  int i;

  fprintf (stderr,
	   "Dump of polynomial statistics (from counters and specific lists):\n");
  fprintf (stderr,
	   "Count of constants=%d, variables=%d, sums=%d, products=%d, functions=%d\n",
	   constantCount, variableCount, sumCount, productCount,
	   functionCallCount);
  fprintf (stderr,
	   "Hits for constants=%d, variables=%d, sums=%d(%d-to-1), products=%d(%d-to-1), functions=%d\n",
	   constantHashHits, variableHashHits, sumHashHits,
	   sumHashHits / sumCount, productHashHits,
	   productHashHits / productCount, functionHashHits);

  constantSize = constantCount * sizeof (Polynomial);
  variableSize = variableCount * sizeof (Polynomial);
  sumSize =
    sumCount * sizeof (Polynomial) + sumCount * sizeof (struct sumPoly);
  for (i = 0; i < sumCount; i++) {
    sumSize +=
      sumList[i]->e.s->num * (sizeof (Polynomial *) + sizeof (double));
    sumTerms += sumList[i]->e.s->num;
  }
  productSize =
    productCount * sizeof (Polynomial) +
    productCount * sizeof (struct productPoly);
  for (i = 0; i < productCount; i++) {
    productSize +=
      productList[i]->e.p->num * (sizeof (Polynomial *) + sizeof (int));
    productTerms += productList[i]->e.p->num;
  }
  functionCallSize =
    functionCallCount * sizeof (Polynomial) +
    functionCallCount * sizeof (struct functionPoly);
  for (i = 0; i < functionCallCount; i++) {
    functionCallSize +=
      strlen (functionCallList[i]->e.f->name) + sizeof (int) +
      sizeof (Polynomial *);
  }

  fprintf (stderr, "Term counts of sums=%d, products=%d\n", sumTerms,
	   productTerms);
  fprintf (stderr,
	   "Sizes: constants=%ld, variables=%ld, sums=%ld, products=%ld, functions=%ld, total=%ld\n",
	   constantSize, variableSize, sumSize, productSize, functionCallSize,
	   constantSize + variableSize + sumSize + productSize +
	   functionCallSize);
  fprintf (stderr,
	   "Sum polys: to release=%d or not=%d are constant=%d single term sum=%d referred to=%d\n",
	   sum0, sum1, sum2, sum3, sum4);
  fprintf (stderr,
	   "...really new=%d new on sumList=%d replaced on sumList=%d\n",
	   sum5, sum00, sum11);
  fprintf (stderr,
	   "Product polys: to release=%d or not=%d are zero=%d are constant=%d same as 1st term=%d\n",
	   product0, product1, product2, product3, product4);
  fprintf (stderr,
	   "...actually a sum poly=%d referred to=%d pre-existing now sum=%d factor is 1=%d\n",
	   product5, product6, product7, product8);
  fprintf (stderr,
	   "...factor not 1 now sum=%d new on productList=%d replaced on productList=%d\n",
	   product9, product00, product11);
  if (sum00 + sum11 > 0)
    fprintf (stderr, "Average sum length=%f ",
	     numSumTerms * 1.0 / (sum00 + sum11));
  if (product00 + product11 > 0)
    fprintf (stderr, "product length=%f\n",
	     numProductTerms * 1.0 / (product00 + product11));

  fprintf (stderr, "Maximum sum length=%d ", maxSumLength);
  for (i = 0; i < maxSumLength; i++)
    if (countSumLength[i] > 0) {
      fprintf (stderr, "(s%d %d) ", i + 1, countSumLength[i]);
      countSumLength[i] = 0;
    }
  fprintf (stderr, "\n");
  fprintf (stderr, "Maximum product length=%d ", maxProductLength);
  for (i = 0; i < maxProductLength; i++)
    if (countProductLength[i] > 0) {
      fprintf (stderr, "(p%d %d) ", i + 1, countProductLength[i]);
      countProductLength[i] = 0;
    }
  fprintf (stderr, "\n");
  fprintf (stderr, "---\n");
};

void
printAllPolynomials ()
{
  int i, j;

  fprintf (stderr, "All Polynomials (from hash):\n");
  if (constantCount > 0) {
    fprintf (stderr, "All %d constants:\n", constantCount);
    for (i = 0; i < CONSTANT_HASH_SIZE; i++) {
      if (constantHash[i].num <= 0)
	continue;
      for (j = 0; j < constantHash[i].num; j++) {
	fprintf (stderr,
		 "(%d %d) index=%d key=%d count=%d valid=%d constant: ", i, j,
		 constantHash[i].index[j], constantHash[i].key[j],
		 constantList[constantHash[i].index[j]]->count,
		 constantList[constantHash[i].index[j]]->valid);
	expTermPrinting (constantList[constantHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
    }
    fprintf (stderr, "\n");
  }
  if (variableCount > 0) {
    fprintf (stderr, "All %d variables:\n", variableCount);
    for (i = 0; i < VARIABLE_HASH_SIZE; i++) {
      if (variableHash[i].num <= 0)
	continue;
      for (j = 0; j < variableHash[i].num; j++) {
	fprintf (stderr,
		 "(%d %d) index=%d key=%d count=%d valid=%d variable: ", i, j,
		 variableHash[i].index[j], variableHash[i].key[j],
		 variableList[variableHash[i].index[j]]->count,
		 variableList[variableHash[i].index[j]]->valid);
	expTermPrinting (variableList[variableHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
    }
    fprintf (stderr, "\n");
  }
  if (sumCount > 0) {
    fprintf (stderr, "All %d sums:\n", sumCount);
    for (i = 0; i < SUM_HASH_SIZE; i++) {
      if (sumHash[i].num <= 0)
	continue;
      for (j = 0; j < sumHash[i].num; j++) {
	fprintf (stderr, "(%d %d) index=%d key=%d count=%d valid=%d sum: ",
		 i, j, sumHash[i].index[j], sumHash[i].key[j],
		 sumList[sumHash[i].index[j]]->count,
		 sumList[sumHash[i].index[j]]->valid);
	expTermPrinting (sumList[sumHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
    }
    fprintf (stderr, "\n");
  }
  if (productCount > 0) {
    fprintf (stderr, "All %d products:\n", productCount);
    for (i = 0; i < PRODUCT_HASH_SIZE; i++) {
      if (productHash[i].num <= 0)
	continue;
      for (j = 0; j < productHash[i].num; j++) {
	fprintf (stderr,
		 "(%d %d) index=%d key=%d count=%d valid=%d product: ", i, j,
		 productHash[i].index[j], productHash[i].key[j],
		 productList[productHash[i].index[j]]->count,
		 productList[productHash[i].index[j]]->valid);
	expTermPrinting (productList[productHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
    }
    fprintf (stderr, "\n");
  }

  if (functionCallCount > 0) {
    fprintf (stderr, "All %d function calls:\n", functionCallCount);
    for (i = 0; i < FUNCTIONCALL_HASH_SIZE; i++) {
      if (functionCallHash[i].num <= 0)
	continue;
      for (j = 0; j < functionCallHash[i].num; j++) {
	fprintf (stderr,
		 "(%d %d) index=%d key=%d count=%d valid=%d functionCall: ",
		 i, j, functionCallHash[i].index[j],
		 functionCallHash[i].key[j],
		 functionCallList[functionCallHash[i].index[j]]->count,
		 functionCallList[functionCallHash[i].index[j]]->valid);
	expTermPrinting (functionCallList[functionCallHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
    }
    fprintf (stderr, "\n");
  }
  fprintf (stderr, "---\n");
}

void
keepAllPolys ()
{
  int i, j;

  fprintf (stderr, "Keeping all current polynomials (via hashes):\n");
  if (constantCount > 0) {
    fprintf (stderr, "All %d constants:\n", constantCount);
    for (i = 0; i < CONSTANT_HASH_SIZE; i++) {
      if (constantHash[i].num <= 0)
	continue;
      for (j = 0; j < constantHash[i].num; j++)
	constantList[constantHash[i].index[j]]->valid++;
    }
  }
  if (variableCount > 0) {
    fprintf (stderr, "All %d variables:\n", variableCount);
    for (i = 0; i < VARIABLE_HASH_SIZE; i++) {
      if (variableHash[i].num <= 0)
	continue;
      for (j = 0; j < variableHash[i].num; j++)
	variableList[variableHash[i].index[j]]->valid++;
    }
  }
  if (sumCount > 0) {
    fprintf (stderr, "All %d sums:\n", sumCount);
    for (i = 0; i < SUM_HASH_SIZE; i++) {
      if (sumHash[i].num <= 0)
	continue;
      for (j = 0; j < sumHash[i].num; j++)
	sumList[sumHash[i].index[j]]->valid++;
    }
  }
  if (productCount > 0) {
    fprintf (stderr, "All %d products:\n", productCount);
    for (i = 0; i < PRODUCT_HASH_SIZE; i++) {
      if (productHash[i].num <= 0)
	continue;
      for (j = 0; j < productHash[i].num; j++)
	productList[productHash[i].index[j]]->valid++;
    }
  }

  if (functionCallCount > 0) {
    fprintf (stderr, "All %d function calls:\n", functionCallCount);
    for (i = 0; i < FUNCTIONCALL_HASH_SIZE; i++) {
      if (functionCallHash[i].num <= 0)
	continue;
      for (j = 0; j < functionCallHash[i].num; j++)
	functionCallList[functionCallHash[i].index[j]]->valid++;
    }
  }
//  printAllPolynomials();
  fprintf (stderr, "---\n");
}

void
incrementValids (struct polynomial *p)
{
  int i;

  switch (p->eType) {
  case T_CONSTANT:
  case T_VARIABLE:
    p->valid = p->valid++ % 32;
    break;
  case T_SUM:
  case T_PRODUCT:
  case T_FUNCTIONCALL:
    p->valid = p->valid++ % 32;
    for (i = 0; i < p->e.s->num; i++) {
      incrementValids (p->e.s->sum[i]);
    }
    break;
  case T_FREED:
    fprintf (stderr,
	     "In incrementValids, evil caller is trying to use a polynomial that was freed:\n");
    expTermPrinting (p);
    exit (1);
    break;
  default:
    fprintf (stderr, "In incrementValids, unknown expression type %d, exiting\n",
	     p->eType);
    exit (1);
  }
}

/* Flag all components of the provided polynomial for preservation. We do
   this by bumping the valid count. */
void
keepPoly (struct polynomial *p)
{
  if (polynomialDebugLevel >= 6) {
    fprintf (stderr, "Starting keepPoly\n");
    if (polynomialDebugLevel >= 7) {
      expTermPrinting (p);
      fprintf (stderr, "\n");
    }
  }
  incrementValids (p);
  if (polynomialDebugLevel >= 6) {
    fprintf (stderr, "Finished keepPoly\n");
    if (polynomialDebugLevel >= 7) {
      printAllPolynomials ();
    }
  }
  return;
}

/* Free all polynomials that we can, i.e. those that don't have a non-zero
   valid counts, and decrementing all valid counts. */
void
freePolys ()
{
  int i, j, k;
  struct polynomial **newSumList, **newProductList;

  if (polynomialDebugLevel >= 6) {
    fprintf (stderr, "Starting freePolys\n");
    if (polynomialDebugLevel >= 7) {
      printAllPolynomials ();
    }
  }
  /* First create a new polynomial-specific list to transcribe entries
     we're keeping, and then go thru the old polynomial-specific list flagging
     entries we're not keeping and replacing pointers with new indexes
     for the ones we are keeping. */
  newSumList =
    (struct polynomial **) malloc (sizeof (struct polynomial *) *
				   (sumListLength));
  if (newSumList == NULL) {
    fprintf (stderr, "In freePolys, newSumList memory application failed, exiting!\n");
    exit (1);
  }
  k = 0;
  for (i = 0; i < sumCount; i++) {
    if (sumList[i]->valid > 0) {
      newSumList[k] = sumList[i];
      sumList[i] = newSumList[k];
//      fprintf(stderr, "Index %d is now %d\n", newSumList[k]->index, k);
      newSumList[k]->index = k;
      k++;
    } else {
//      free (sumList[i]->e.s->sum);
//      free (sumList[i]->e.s->factor);
//      free (sumList[i]->e.s);
//      free (sumList[i]);
      sumList[i]->value = sumList[i]->eType;
      sumList[i]->eType = T_FREED;
      sumList[i] = NULL;
    }
  }
  if (polynomialDebugLevel >= 4) fprintf(stderr, "Kept %d of %d sum polynomials\n", k, sumCount);
  sumCount = k;

  /* Go thru the hash collapsing entries and freeing the corresponding
     polynomials and terms. Zero polynomial-specific list entries so they
     can be collapsed next. */
  for (j = 0; j < SUM_HASH_SIZE; j++) {
    if (sumHash[j].num > 0) {
      k = 0;
      for (i = 0; i < sumHash[j].num; i++) {
	if (sumList[sumHash[j].index[i]] != NULL) {
	  /* It's a keeper, slide it down and bump the count */
//        fprintf(stderr, "Hash keeper index %d is now %d\n", sumHash[j].index[i],
//              sumList[sumHash[j].index[i]]->index);
	  sumHash[j].index[k] = sumList[sumHash[j].index[i]]->index;
	  sumHash[j].key[k] = sumHash[j].key[i];
	  k++;
	}
      }
      sumHash[j].num = k;
    }
  }
  free (sumList);
  sumList = newSumList;

  newProductList =
    (struct polynomial **) malloc (sizeof (struct polynomial *) *
				   (productListLength));
  if (newProductList == NULL) {
    fprintf (stderr, "In freePolys, newProductList memory application failed, exiting!\n");
    exit (1);
  }
  k = 0;
  for (i = 0; i < productCount; i++) {
    if (productList[i]->valid > 0) {
      newProductList[k] = productList[i];
      productList[i] = newProductList[k];
//      fprintf(stderr, "Index %d is now %d\n", newProductList[k]->index, k);
      newProductList[k]->index = k;
      k++;
    } else {
//      free (productList[i]->e.p->product);
//      free (productList[i]->e.p->exponent);
//      free (productList[i]->e.p);
//      free (productList[i]);
      productList[i]->value = productList[i]->eType;
      productList[i]->eType = T_FREED;
      productList[i] = NULL;
    }
  }
  if (polynomialDebugLevel >= 4) fprintf(stderr, "Kept %d of %d product polynomials\n", k, productCount);
  productCount = k;

  /* Go thru the hash collapsing entries and freeing the corresponding
     polynomials and terms. Zero polynomial-specific list entries so they
     can be collapsed next. */
  for (j = 0; j < PRODUCT_HASH_SIZE; j++) {
    if (productHash[j].num > 0) {
      k = 0;
      for (i = 0; i < productHash[j].num; i++) {
	if (productList[productHash[j].index[i]] != NULL) {
	  /* It's a keeper, slide it down and bump the count */
//        fprintf(stderr, "Hash keeper index %d is now %d\n", productHash[j].index[i],
//              productList[productHash[j].index[i]]->index);
	  productHash[j].index[k] =
	    productList[productHash[j].index[i]]->index;
	  productHash[j].key[k] = productHash[j].key[i];
	  k++;
	}
      }
      productHash[j].num = k;
    }
  }
  free (productList);
  productList = newProductList;

  if (polynomialDebugLevel >= 6) {
    fprintf (stderr, "Reduced list of polynomials\n");
    if (polynomialDebugLevel >= 7) {
      printAllPolynomials ();
      printHashTables ();
    }
  }
  return;
}
