#define MAXPOLYTIERS 13
int polyTiers[MAXPOLYTIERS][5];
int peakPolyTiers;
char *polyTypes[] = { "constant", "variable", "sum", "product", "function" };

/* It might not be a sumPoly, but we can treat it as one. */
void
traversePoly (struct polynomial *p, int currentTier)
{
  int i;

  fprintf (stderr, "%d(%d) ", p->id, p->count);
  if (currentTier > peakPolyTiers)
    peakPolyTiers = currentTier;
  if (currentTier >= MAXPOLYTIERS)
    return;
  polyTiers[currentTier][p->eType]++;
  switch (p->eType) {
  case T_CONSTANT:
  case T_VARIABLE:
    break;
  case T_SUM:
    for (i = 0; i < p->e.s->num; i++) {
      traversePoly (p->e.s->sum[i], currentTier + 1);
    }
    break;
  case T_PRODUCT:
    for (i = 0; i < p->e.p->num; i++) {
      traversePoly (p->e.p->product[i], currentTier + 1);
    }
    break;
  case T_FUNCTIONCALL:
    for (i = 0; i < p->e.f->paraNum; i++) {
      traversePoly (p->e.f->para[i], currentTier + 1);
    }
    break;
  default:
    fprintf (stderr, "Error, Unknown expression type: [%d], exiting!\n",
	     p->eType);
    exit (1);
  }
}
void
printSummaryPoly (struct polynomial *p)
{
  int i, j;

  fprintf (stderr, "Summary of Remains of %d Polynomials:\n", nodeId);
  memset (polyTiers, 0, sizeof (polyTiers));
  peakPolyTiers = 0;
  traversePoly (p, 0);
  for (i = 0; i <= peakPolyTiers; i++) {
    fprintf (stderr, "Tier %d:", i);
    int firstPrint = 1;

    for (j = 0; j < 5; j++) {
      if (polyTiers[i][j] != 0) {
	if (!firstPrint)
	  fprintf (stderr, ",");
	firstPrint = 0;
	fprintf (stderr, " %d %s", polyTiers[i][j], polyTypes[j]);
	if (polyTiers[i][j] > 1)
	  fprintf (stderr, "s");
      }
    }
    fprintf (stderr, "\n");
  }
  fprintf (stderr, "---\n");
}

void
expPrinting (struct polynomial *p)
{
  int i;

  switch (p->eType) {
  case T_CONSTANT:
    fprintf (stderr, "%G", p->value);
    break;
  case T_VARIABLE:
    if (strlen (p->e.v->vName) == 0)
      fprintf (stderr, "unnamed%d", p->index);
    else
      fprintf (stderr, "%s", p->e.v->vName);
    break;
  case T_SUM:
    if (p->e.s->num > 1)
      fprintf (stderr, "(");
    if (p->e.s->factor[0] != 1)
      fprintf (stderr, "%G*", p->e.s->factor[0]);
    expPrinting (p->e.s->sum[0]);
    for (i = 0; i < p->e.s->num; i++) {
      fprintf (stderr, "+");
      if (p->e.s->factor[i] != 1)
	fprintf (stderr, "%G*", p->e.s->factor[i]);
      expPrinting (p->e.s->sum[i]);
    }
    if (p->e.s->num > 1)
      fprintf (stderr, ")");
    break;
  case T_PRODUCT:
    if (p->e.p->num > 1)
      fprintf (stderr, "(");
    expPrinting (p->e.p->product[0]);
    if (p->e.p->exponent[0] != 1)
      fprintf (stderr, "^%d", p->e.p->exponent[0]);
    for (i = 1; i < p->e.s->num; i++) {
      fprintf (stderr, "*");
      expPrinting (p->e.p->product[i]);
      if (p->e.p->exponent[i] != 1)
	fprintf (stderr, "^%d", p->e.p->exponent[i]);
    }
    if (p->e.p->num > 1)
      fprintf (stderr, ")");
    break;
  case T_FUNCTIONCALL:
    fprintf (stderr, "%s(", p->e.f->name);
    for (i = 0; i < p->e.f->paraNum - 1; i++) {
      expPrinting (p->e.f->para[i]);
      fprintf (stderr, ", ");
    }
    expPrinting (p->e.f->para[p->e.f->paraNum - 1]);
    fprintf (stderr, ")");
    break;
  default:
    fprintf (stderr, "Unknown expression type %d exit!!!!!, exit(5)\n",
	     p->eType);
    exit (1);
  }
}

/*
 This function prints out polynomial statistic information.  It is mainly used for 
 performance evaluation and debugging. */
void
polyStatistics ()
{
  long constantSize, variableSize, sumSize, productSize, functionCallSize;
  int sumTerms = 0, productTerms = 0;
  int i;

  fprintf (stderr, "Dump of polynomial statistics:\n");
  fprintf (stderr,
	   "Count of constants=%d, variables=%d, sums=%d, products=%d, functions=%d\n",
	   constantCount, variableCount, sumCount, productCount,
	   functionCallCount);
  fprintf (stderr,
	   "Hits for constants=%d, variables=%d, sums=%d(%d-to-1), products=%d(%d-to-1), functions=%d\n",
	   constantHashHits, variableHashHits, sumHashHits,
	   sumHashHits / sumCount, productHashHits,
	   productHashHits / productCount, functionHashHits);

  constantSize = constantCount * sizeof (Polynomial);
  variableSize = variableCount * sizeof (Polynomial);
  sumSize =
    sumCount * sizeof (Polynomial) + sumCount * sizeof (struct sumPoly);
  for (i = 0; i < sumCount; i++) {
    sumSize +=
      sumList[i]->e.s->num * (sizeof (Polynomial *) + sizeof (double));
    sumTerms += sumList[i]->e.s->num;
  }
  productSize =
    productCount * sizeof (Polynomial) +
    productCount * sizeof (struct productPoly);
  for (i = 0; i < productCount; i++) {
    productSize +=
      productList[i]->e.p->num * (sizeof (Polynomial *) + sizeof (int));
    productTerms += productList[i]->e.p->num;
  }
  functionCallSize =
    functionCallCount * sizeof (Polynomial) +
    functionCallCount * sizeof (struct functionPoly);
  for (i = 0; i < functionCallCount; i++) {
    functionCallSize +=
      strlen (functionCallList[i]->e.f->name) + sizeof (int) +
      sizeof (Polynomial *);
  }

  fprintf (stderr, "Term counts of sums=%d, products=%d\n", sumTerms,
	   productTerms);
  fprintf (stderr,
	   "Sizes: constants=%ld, variables=%ld, sums=%ld, products=%ld, functions=%ld, total=%ld\n",
	   constantSize, variableSize, sumSize, productSize, functionCallSize,
	   constantSize + variableSize + sumSize + productSize +
	   functionCallSize);
  fprintf (stderr,
	   "Sum polys: to release=%d or not=%d are constant=%d single term sum=%d referred to=%d\n",
	   sum0, sum1, sum2, sum3, sum4);
  fprintf (stderr,
	   "...really new=%d new on sumList=%d replaced on sumList=%d\n",
	   sum5, sum00, sum11);
  fprintf (stderr,
	   "Product polys: to release=%d or not=%d are zero=%d are constant=%d same as 1st term=%d\n",
	   product0, product1, product2, product3, product4);
  fprintf (stderr,
	   "...actually a sum poly=%d referred to=%d pre-existing now sum=%d factor is 1=%d\n",
	   product5, product6, product7, product8);
  fprintf (stderr,
	   "...factor not 1 now sum=%d new on productList=%d replaced on productList=%d\n",
	   product9, product00, product11);
  if (sum00 + sum11 > 0)
    fprintf (stderr, "Average sum length=%f ",
	     numSumTerms * 1.0 / (sum00 + sum11));
  if (product00 + product11 > 0)
    fprintf (stderr, "product length=%f\n",
	     numProductTerms * 1.0 / (product00 + product11));

  fprintf (stderr, "Maximum sum length=%d ", maxSumLength);
  for (i = 0; i < maxSumLength; i++)
    if (countSumLength[i] > 0) {
      fprintf (stderr, "(s%d %d) ", i + 1, countSumLength[i]);
      countSumLength[i] = 0;
    }
  fprintf (stderr, "\n");
  fprintf (stderr, "Maximum product length=%d ", maxProductLength);
  for (i = 0; i < maxProductLength; i++)
    if (countProductLength[i] > 0) {
      fprintf (stderr, "(p%d %d) ", i + 1, countProductLength[i]);
      countProductLength[i] = 0;
    }
  fprintf (stderr, "\n");
  fprintf (stderr, "---\n");
};

void
printAllPolynomials ()
{
  int i, j;

  fprintf (stderr, "All Polynomials from Hash:\n");
  if (constantCount > 0) {
    fprintf (stderr, "All %d constants:\n", constantCount);
    for (i = 0; i < CONSTANT_HASH_SIZE; i++) {
      if (constantHash[i].num <= 0)
	continue;
      for (j = 0; j < constantHash[i].num; j++) {
	fprintf (stderr,
		 "(%d %d) index=%d key=%d count=%d valid=%d constant: ", i, j,
		 constantHash[i].index[j], constantHash[i].key[j],
		 constantList[constantHash[i].index[j]]->count,
		 constantList[constantHash[i].index[j]]->valid);
	expPrinting (constantList[constantHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
      fprintf (stderr, "\n");
    }
    fprintf (stderr, "\n");
  }
  if (variableCount > 0) {
    fprintf (stderr, "All %d variables:\n", variableCount);
    for (i = 0; i < VARIABLE_HASH_SIZE; i++) {
      if (variableHash[i].num <= 0)
	continue;
      for (j = 0; j < variableHash[i].num; j++) {
	fprintf (stderr, "(%d %d) index=%d key=%d count=%d variable: ",
		 i, j, variableHash[i].index[j], variableHash[i].key[j],
		 variableList[variableHash[i].index[j]]->count);
	expPrinting (variableList[variableHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
    }
    fprintf (stderr, "\n");
  }
  if (sumCount > 0) {
    fprintf (stderr, "All %d sums:\n", sumCount);
    for (i = 0; i < SUM_HASH_SIZE; i++) {
      if (sumHash[i].num <= 0)
	continue;
      for (j = 0; j < sumHash[i].num; j++) {
	fprintf (stderr, "(%d %d) index=%d key=%d count=%d sum: ",
		 i, j, sumHash[i].index[j], sumHash[i].key[j],
		 sumList[sumHash[i].index[j]]->count);
	expPrinting (sumList[sumHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
      fprintf (stderr, "\n");
    }
    fprintf (stderr, "\n");
  }
  if (productCount > 0) {
    fprintf (stderr, "All %d products:\n", productCount);
    for (i = 0; i < PRODUCT_HASH_SIZE; i++) {
      if (productHash[i].num <= 0)
	continue;
      for (j = 0; j < productHash[i].num; j++) {
	fprintf (stderr, "(%d %d) index=%d key=%d count=%d product: ",
		 i, j, productHash[i].index[j], productHash[i].key[j],
		 productList[productHash[i].index[j]]->count);
	expPrinting (productList[productHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
      fprintf (stderr, "\n");
    }
    fprintf (stderr, "\n");
  }

  if (functionCallCount > 0) {
    fprintf (stderr, "All %d function calls:\n", functionCallCount);
    for (i = 0; i < FUNCTIONCALL_HASH_SIZE; i++) {
      if (functionCallHash[i].num <= 0)
	continue;
      for (j = 0; j < functionCallHash[i].num; j++) {
	fprintf (stderr, "(%d %d) index=%d key=%d count=%d functionCall: ",
		 i, j, functionCallHash[i].index[j],
		 functionCallHash[i].key[j],
	functionCallList[functionCallHash[i].index[j]]->count);
	expPrinting (functionCallList[functionCallHash[i].index[j]]);
	fprintf (stderr, "\n");
      }
      fprintf (stderr, "\n");
    }
    fprintf (stderr, "\n");
  }
  fprintf (stderr, "---\n");
}
