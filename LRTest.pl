#!/usr/bin/perl -w
use strict;
use Data::Dumper;

#####################################
#
# $Id$
#
# by Bill Valentine-Cooper
#
# Copyright 2008, Nationwide Children's Research Institute.  All
# rights reserved.  Permission is hereby given to use this software
# for non-profit educational purposes only.
#
# Perform LR comparison tests on a kelvin dynamic grid configuration. Makes 
# extensive use of GNU baseutils, i.e. grep, sort, uniq. Expects TEST_KELVIN
# environment variable to point to version of kelvin to run. Requires kelvin
# V0.38 or later to support new directives and command-line directives.
#
# 1. Run kelvin with the kelvin.conf in the current directory, with the addition
# of the SurfaceFile directive.
#
# 2. Parse the SurfaceFile output header (starts with some spacing variation of 
# "# HLOD') to identify the trait space variables. All trait space variables must 
# have equivalent directives in %nameDirectives.
#
# 3. Find rows in the SurfaceFile output that have min and max values for each of
# the trait space variables. These will be used as test points.
#
# 4. Find 10? more randomly-chosen rows in the SurfaceFile output that are not the
# same as the ones already chose. These will be used as additional test points.
#
# 5. For each test point, run kelvin with the same kelvin.conf, with the addition 
# of the FixedGrids directive and all of the directives needed to choose that single 
# trait space test point.
#
# 6. Verify that all of the SurfaceFile outputs generated by the fixed grid test runs 
# are in the dynamic grid SurfaceFile output. If not, there's a problem.
#

my $EXTRACHOICES = 10; # Number of random choices excluding min/max choices
sub numerically { $a <=> $b } # Sort things numerically

# Associate column headers with configuration file directives
my %nameDirectives = (
		      'Theta' => 'Theta', 
		      'Theta-M' => 'Theta', 
		      'Theta-F' => 'Theta', 
		      'Alpha' => 'Alpha',
		      'DGF' => 'DiseaseGeneFrequency', 
		      'LC1PV-DD' => 'Penetrance DD',
		      'LC1PV-Dd' => 'Penetrance Dd',
		      'LC1PV-dD' => 'Penetrance dD',
		      'LC1PV-dd' => 'Penetrance dd',
		      'LC1DoFV-DD' => 'DegreesOfFreedom DD',
		      'LC1DoFV-Dd' => 'DegreesOfFreedom Dd',
		      'LC1DoFV-dD' => 'DegreesOfFreedom dD',
		      'LC1DoFV-dd' => 'DegreesOfFreedom dd',
		      'LC1MV-DD' => 'Mean DD',
		      'LC1MV-Dd' => 'Mean Dd',
		      'LC1MV-dD' => 'Mean dD',
		      'LC1MV-dd' => 'Mean dd',
		      'LC2PV-DD' => 'Penetrance DD',
		      'LC2PV-Dd' => 'Penetrance Dd',
		      'LC2PV-dD' => 'Penetrance dD',
		      'LC2PV-dd' => 'Penetrance dd',
		      'LC2DoFV-DD' => 'DegreesOfFreedom DD',
		      'LC2DoFV-Dd' => 'DegreesOfFreedom Dd',
		      'LC2DoFV-dD' => 'DegreesOfFreedom dD',
		      'LC2DoFV-dd' => 'DegreesOfFreedom dd',
		      'LC2MV-DD' => 'Mean DD',
		      'LC2MV-Dd' => 'Mean Dd',
		      'LC2MV-dD' => 'Mean dD',
		      'LC2MV-dd' => 'Mean dd',
		      'LC3PV-DD' => 'Penetrance DD',
		      'LC3PV-Dd' => 'Penetrance Dd',
		      'LC3PV-dD' => 'Penetrance dD',
		      'LC3PV-dd' => 'Penetrance dd',
		      'LC3DoFV-DD' => 'DegreesOfFreedom DD',
		      'LC3DoFV-Dd' => 'DegreesOfFreedom Dd',
		      'LC3DoFV-dD' => 'DegreesOfFreedom dD',
		      'LC3DoFV-dd' => 'DegreesOfFreedom dd',
		      'LC3MV-DD' => 'Mean DD',
		      'LC3MV-Dd' => 'Mean Dd',
		      'LC3MV-dD' => 'Mean dD',
		      'LC3MV-dd' => 'Mean dd',
		      'Dprime' => 'DPrime',
		      'SD' => 'StandardDev',
		      'Thresh' => 'Threshold',
		      'MkIdx' => 'Dummy', # Dummy directive (no action)
		      'PosIdx' => 'Dummy', # "
		      );

my  @headerNames = ();
sub parse_header {
    my @words = split;
    shift @words; # Ditch HLOD
    for my $word (@words) {
	if ($word =~ /(\S+)\((.*,.*)\)/) {
	    for my $partial (split(",",$2)) {
		die "ERROR, Directive unknown for group column header ".$1."-".$partial."\n"
		    if (!defined($nameDirectives{$1."-".$partial}));
		push @headerNames, $1."-".$partial;
	    }
	} else {
	    die "ERROR, Directive unknown for column header $word\n"
		if (!defined($nameDirectives{$word}));
	    push @headerNames, $word;
	}
    }
}

# Run kelvin on the config file with SurfaceFile directive
print "Generating dynamic-grid trait space baseline.\n";
my $commandLine='$TEST_KELVIN kelvin.conf --SurfaceFile LRTest.Dyn >LRTest.Out 2>&1';
(system($commandLine) == 0)
    or die "ERROR, Couldn't run kelvin ($commandLine)\n";

# First pass thru file, pull-out min and max rows...
open IN,"LRTest.Dyn";

while (<IN>) {
    s/^\s*//g;       # Trim leading whitespace
    &parse_header($_) if (/\#\w*HLOD/);
    s/\s*\#.*//g;    # Trim comments
    next if (/^$/);  # Drop empty lines
    last;
}
my @words = split;
my $paramCnt = ($#words)-1;
my $HLOD = shift(@words); # Current HLOD
my @PsHLOD = (); # Each parameter's HLOD
my @PsTSV = (); # Each parameter's trait space values
my @PsLine = (); # Each parameter's original file line number
# Mins for each parameter are in element corresponding to parameter ordinality, and
# maxes are in element corresponding to parameter ordinality + number of parameters.
for my $i (0..$paramCnt) {
    $PsHLOD[$i] = $PsHLOD[$i+$paramCnt] = $HLOD;
    $PsTSV[$i] = $PsTSV[$i+$paramCnt] = [ @words ];
    $PsLine[$i] = $PsLine[$i+$paramCnt] = 0;
}
my $line = 0;
while (<IN>) {
    $line++;
    @words = split;
    $HLOD = shift(@words);
    # Pull the entry with the lowest/highest values for each trait space parameter
    for my $i (0..$paramCnt) {
	if ($words[$i] < $PsTSV[$i][$i]) {
	    $PsHLOD[$i] = $HLOD;
	    $PsTSV[$i] = [ @words ];
	    $PsLine[$i] = $line;
	}
	if ($words[$i] > $PsTSV[$i+$paramCnt][$i]) {
	    $PsHLOD[$i+$paramCnt] = $HLOD;
	    $PsTSV[$i+$paramCnt] = [ @words ];
	    $PsLine[$i+$paramCnt] = $line;
	}
    }
}
close IN;
my %avoidLines = ();
for my $i (0..$paramCnt) {
#    print "Parameter $i min at line ".$PsLine[$i]." of ".$PsTSV[$i][$i]." has HLOD ".
#	$PsHLOD[$i]."/TSV ".Dumper($PsTSV[$i])."\n";
    $avoidLines{$PsLine[$i]} = 1;
#    print "Parameter $i max at line ".$PsLine[$i+$paramCnt]." of ".
#	$PsTSV[$i+$paramCnt][$i]." has HLOD ".$PsHLOD[$i+$paramCnt].
#	"/TSV ".Dumper($PsTSV[$i+$paramCnt])."\n";
    $avoidLines{$PsLine[$i+$paramCnt]} = 1;
}
# Second pass thru file choosing N random ones not already chosen! This
# can be a fascinating problem if you're trying to find the 
# "cardinal intersection" of a set of columns. Unfortunately it would
# take time to figure out, and we're (always) in a hurry.
my @randLines = ();
my $choices = 0;
while ($choices < $EXTRACHOICES) {
    my $choice = int(rand($line));
    if (!defined($avoidLines{$choice})) {
	push @randLines, $choice;
	$choices++;
    }
}
@randLines = sort numerically @randLines;
#print "...and grab these lines too: ".Dumper(\@randLines)."\n";
open IN,"LRTest.Dyn";
$line = 0;
my $nextLine = shift(@randLines);
my $offset = $paramCnt * 2;
while (<IN>) {
    $line++;
    if ($line == $nextLine) {
	@words = split;
	$PsHLOD[$offset] = shift(@words);
	$PsTSV[$offset] = [ @words ];
	$PsLine[$offset] = $line;
	$offset++;
	$nextLine = shift(@randLines);
	last if (!defined($nextLine));
    }
}
close IN;

# Clean-out any earlier results. Allow this to fail.
system('rm LRTest-* > /dev/null 2>&1');

# Generate all of the kelvin configuration variations and run them
my $searchFormat = " " . ("%5.3f " x $paramCnt) . "%d";
for my $i (0..($offset - 1)) {
    my $commandLine = '$TEST_KELVIN kelvin.conf --FixedModels';
#    print "Test from line ".$PsLine[$i]." has HLOD ".
#	$PsHLOD[$i]."/TSV ".Dumper($PsTSV[$i])."\n";
    for my $j (0..$paramCnt) {
#	print "|".$nameDirectives{$headerNames[$j]}." ".$PsTSV[$i][$j]."\n";
	$commandLine .= " --".$nameDirectives{$headerNames[$j]}." ".$PsTSV[$i][$j];
    }
    $commandLine .= " --SurfaceFile LRTest-$i.Dat > LRTest-$i.Out 2>&1";
    $commandLine =~ s/--Dummy\s+[0-9]+/ /g; # Lose our dummy directives
    $commandLine =~ s/--DiseaseGeneFrequency 0\.000/--DiseaseGeneFrequency 0\.00049 /g;
    print "Generating fixed-grid trait space test point $i from dynamic grid output line ".$PsLine[$i].".\n";
    print "Execute [$commandLine]\n";
    (system($commandLine) == 0) or die "ERROR, Couldn't run \'$commandLine\'\n";
# Filter-out unrequested results, e.g. same parameters different marker, 0.5 Theta, etc.
    my $searchLine = sprintf($searchFormat, @{ $PsTSV[$i] }, $PsTSV[$i][$paramCnt]);
    $searchLine .= '$';
    print "Limit by [$searchLine]\n";
    $commandLine = "grep \'$searchLine\' LRTest-$i.Dat >LRTest-$i.Fix";
    (system($commandLine) == 0) or die "ERROR, Couldn't run \'$commandLine\'\n";
}

# Now concatenate, uniq-ify and compare all of the output, then let our driver do
# the differences and react accordingly.
(system('cat LRTest-*.Fix | sort | uniq > LRTest.Fix') == 0) or
    die "ERROR, Cannot concatenate, sort or uniq all fixed-grid results\n";

# Find each fixed line in the dynamic output (using a possibly rounded HLOD).
print "Finding fixed results in dynamic results";
open IN,"LRTest.Fix";
while (<IN>) {
    chomp;
    print ".";
    if ($_ =~ /^([ \-][0-9]*\.[0-9]{3})/) {
        # Heavy on the rounding slop. Go ahead and ask Sang for more surface precision!
	my $old = $1;
	my $new;
	my $scale = 0.001;
	$scale = 10**(int(log(abs($old))/log(10)) - 2) if (abs($old) >= 1.0);
        # Exact match for enumerated HLODs within +/-5%
	$new = sprintf("[%5.3f |%5.3f |%5.3f |%5.3f |%5.3f |%5.3f |%5.3f |%5.3f |%5.3f |%5.3f |%5.3f ]",
		       $1-(5*$scale), $1-(4*$scale), $1-(3*$scale), $1-(2*$scale), $1-$scale, $1, 
		       $1+$scale, $1+(2*$scale), $1+(3*$scale), $1+(4*$scale), $1+(5*$scale));
	$new =~ s/[ \-]0.000/ 0.000|-0.000/g;
#	print "HLOD is [$old], using $new\n";
	s/$old/$new/;
	s/\-/\\\-/;
    }
    (system("grep \"".$_."\" LRTest.Dyn > LRTest.grep 2>&1") == 0) or
	die "ERROR, Couldn't find line \"$_\" in LRTest.Dyn\n";
}
close IN;
print "done!\n";
