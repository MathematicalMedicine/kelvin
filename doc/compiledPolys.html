<h1>Polynomial Compilation</h1>
Polynomial compilation is a method of post-processing the in-memory polynomials generated by kelvin
so as to facilitate rapid evaluation and reuse. Compiled polynomials are stored as dynamic libraries
that are loaded on-demand and evaluate up to ten times faster than their in-memory counterparts. Once
a dynamic library is built for a polynomial, the relatively slow and memory-intensive process of generating
the polynomial need not be performed again unless the analysis characteristics change. Only named polynomials
can be compiled and reused, and as of this version of kelvin, named polynomials are those unique to each
pedigree and combination of marker/trait positions in the analysis. For example, a multipoint analysis with
3 pedigrees and 3 markers, where trait positions occur between every marker pair would generate the following
named polynomials:
<ul>
<li>pedigree 1, T-M1-M2-M3
<li>pedigree 2, T-M1-M2-M3
<li>pedigree 1, M1-T-M2-M3
<li>pedigree 2, M1-T-M2-M3
<li>pedigree 1, M1-M2-T-M3
<li>pedigree 2, M1-M2-T-M3
<li>pedigree 1, M1-M2-M3-T
<li>pedigree 2, M1-M2-M3-T
</ul>
Note that regardless of the density or distribution of evaluated trait positions in the analysis, no further
named polynomials will be needed, as all possible combinations of marker/trait relationships are in the list.
This is not unique to compilation -- it is one of the advantages of using polynomials that carries over into
compilation.

<h2>Phases in Polynomial Compilation</h2>
Polynomial compilation consists of three phases that have very different requirements and optimization
possibilities:
<ol>
<li><b>Polynomial build and code generation.</b> This is the normal process of polynomial building that occurs whenever
you use the <tt>PE</tt> directive in your analysis, coupled with the fairly quick additional 
step of generating <tt>C</tt> code to represent the polynomial. This step can be very memory-intensive depending
upon the complexity of the pedigrees and number of positions, and does not benefit significantly from running in
a multi-threaded environment.
<li><b>Code compilation and dynamic library (DL) linking.</b>
Compilation can be performed at the time the source is generated by kelvin itself,
or by way of batch jobs submitted on multiple
nodes. These two approaches are incompatible because if kelvin is doing the compiling, it expects that when
it gets done there will be a ready-to-load dynamic library. This will not be the case if the compilation is
being distributed to multiple nodes via batch jobs. There are, therefore, two ways to go:
<ol>
<li> Run kelvin-POLYCOMP_DL, which will generate, compile, link and use dynamic libraries all by itself, or
<li> Use a multi-step approach:
<ol>
<li>Run kelvin-POLYCODE_DL-FAKEEVALUATE, which will generate the code for dynamic libraries, but neither
compile nor try to load and use them. This is platform-independent, possibly memory-intensive, and single-
threaded.
<li>Compile (and ultimately link) all of the source files generated. This can be done on any 
linux nodes that are hardware-compatible
with the platform to be used in the evaluation step. It can be performed thoroughly in parallel, and even
started while the previous step is still running so long as polynomial code is available to compile.
<li>Run kelvin-POLYUSE_DL. Once all generated polynomials are compiled and linked, kelvin-POLYUSE_DL will be
able to load and use them instead of generating the polynomials. This step uses only a fraction
(generally a third or less) of the memory required to hold a normal polynomial, and allows rapid, multi-
threaded evaluation of the separate pedigree polynomials for each position.
</ol>
</ol>

<h2>When to Use Polynomial Compilation</h2>
Generally, you should use polynomial compilation only when it is feasible in your computational environment and
the cost and complexity of compiling and linking dynamic libraries is exceeded by the benefits of rapid
and repeatable evaluation.
<h3>Indications</h3>
<ul>
<li>When the ratio of evaluations to trait/marker position changes is high. This is an indication to use
polynomial evaluation in general, and compilation in particular.
<li>When the run-time of an evalution is prohibitive. Compilation can reduce evaluation time by up to an
order of magnitude.
<li>When the same set of markers will be used with varying sets of pedigrees in multiple analyses. Since named
polynomials are specific to pedigree and trait/marker position, analyses that consider various subsets of a group
of pedigrees pay the price of compilation only once for each pedigree and trait/marker position, and then reuse
them without additional cost.
</ul>
<h3>Counterindications</h3>
<li>When pedigrees are very simple.
<li>When only a single evaluation will be performed.
</ul>
