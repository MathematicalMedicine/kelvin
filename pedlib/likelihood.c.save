/**********************************************************************
 * Copyright 2007, Columbus Children's Research Institute.  
 * All rights reserved.
 * Permission is hereby given to use this software 
 * for non-profit educational purposes only.
 **********************************************************************/

/* This file contains functions to  compute likelihood for all the pedigrees,
 * peeling procedure etc. 
 * */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <sys/types.h>

#include "pedlib.h"
#include "locus.h"
#include "utils.h"		/* for logging */
#include "tools.h"
#include "likelihood.h"
#include "genotype_elimination.h"
#include "polynomial.h"

/* transmission probability matrix */
XMission *xmissionMatrix = NULL;

/* temporary likelihood results for related parental pairs */
typedef struct PPairElement
{
  /* index to the conditional likelihood array of the proband's */
  u_int32_t likelihoodIndex;
  /* number of the same likelihood */
  short count;
  /* temporary likelihood result */
  union {
    double likelihood;
#ifndef NO_POLYNOMIAL
    /* likelihood polynomial under polynomial mode */
    Polynomial *likelihoodPolynomial;
#endif
  }slot;
} PPairElement;

PPairElement **ppairMatrix = NULL;
int ppairMatrixSize; 


int peel_graph (NuclearFamily * pNucFam, Person * pProband,
		int peelingDirection);
int compute_nuclear_family_likelihood (NuclearFamily * pNucFam,
				       Person * pProband,
				       int peelingDirection);
int
loop_parental_pair (NuclearFamily * pNucFam,
		    Person * pPerson,
		    int locus,
		    ParentalPairSpace * pHaplo,
		    int multiLocusIndex[2],
		    void *dWeight[2]);
int
loop_child_multi_locus_genotype (Person * pPChild, Person * pProband,
				 ParentalPairSpace * pHaplo, int child,
				 int locus, int multiLocusIndex,
				 void *pSum, 
				 int xmissionIndex[2]);
void
get_haplotype_freq (int locus, int parent, void *freqPtr,
		    ParentalPairSpace * pHaplo);

int
loop_child_proband_genotype (NuclearFamily * pNucFam, Person * pProband,
			     int peelingDirection, int locus,
			     int multiLocusIndex);

void
loop_phases (NuclearFamily * pNucFam, ParentalPairSpace * pHaplo,
	     Person * pProband, int locus, int multiLocusIndex[2],
	     int multiLocusPhase[2], void *dWeight[2]);


/* before likelihood calculation, pre-allocate space to store conditional likelihoods 
 * numLocus - number of loci we analyze at a time
 */
int
allocate_likelihood_space (PedigreeSet * pPedigreeList, int numLocus)
{
  Pedigree *pPedigree;
  int i;

  for (i = 0; i < pPedigreeList->numPedigree; i++)
    {
      pPedigree = pPedigreeList->ppPedigreeSet[i];
      /* allocate conditional likelihood storage for each person/pedigree */
      allocate_multi_locus_genotype_storage (pPedigree, numLocus);
    }

  /* allocate storage for temporarily stored likelihood for similar parental pairs (only with
   * phase differences 
   * either likelihood itself will be stored there or a pointer to likelihood polynomial will be */
  ppairMatrixSize = pow(4, numLocus) * sizeof(PPairElement); 
  ppairMatrix =
    (PPairElement **) calloc (pow (2, numLocus), sizeof (PPairElement *));
  for (i = 0; i < numLocus; i++)
    {
      ppairMatrix[i] =
	(PPairElement *) calloc (pow (2, numLocus), sizeof (PPairElement));
    }

  return 0;
}

/* free the storage space for conditionals */
void
free_likelihood_space (PedigreeSet * pPedigreeList)
{
  Pedigree *pPedigree;
  int i;

  for (i = 0; i < pPedigreeList->numPedigree; i++)
    {
      pPedigree = pPedigreeList->ppPedigreeSet[i];
      free_multi_locus_genotype_storage (pPedigree);
    }

  /* free storage for temporary likelihood for similar parental pairs */
  for(i=0; i < locusList->numLocus; i++)
    {
      free(ppairMatrix[i]);
    }
  free(ppairMatrix);
}

/* the main API to compute likelihood for all pedigrees in a data set */
int
compute_likelihood (PedigreeSet * pPedigreeList)
{
  Pedigree *pPedigree;
  int i;
  int status; /* return status of function calls */
  double product_likelihood = 1;  /* product of the likelihoods for all the pedigrees */
  double sum_log_likelihood = 0;   /* sum of the log10(likelihood) for all the pedigrees */
  double log10Likelihood;
  int origLocus = locusList->pLocusIndex[1];  /* locus index in the original locus list 
					       * this is used to find out the pedigree counts
					       * mainly for case control analyses 
					       */


  /* initialization */
  sum_log_likelihood = 0;
  product_likelihood = 1;
  pPedigreeList->likelihood = 1;
  pPedigreeList->log10Likelihood = 0;

  /* loop over pedigrees in the data set */
  for (i = 0; i < pPedigreeList->numPedigree; i++)
    {
      pPedigree = pPedigreeList->ppPedigreeSet[i];

#ifndef NO_POLYNOMIAL
      if (modelOptions.polynomial == TRUE)
	{
	  if (pPedigree->likelihoodPolynomial == NULL)
	    {
	      /* only build likelihood polynomial once, if the ptr is not NULL, it means
	       * the polynomial has been constructed */
//            fprintf(stderr,"The polynomial building for this pedigree should be only once\n");
	      /* initialize likelihood space for each pedigree */
	      initialize_multi_locus_genotype (pPedigree);
//                fprintf(stderr,"Start polynomial building\n");
	      /* put a stamp in the polynomial list to mark the beginning of likelihood build
	       * for this pedigree */
	      makePolynomialStamp2 ();
	      status = compute_pedigree_likelihood (pPedigree);

//                expPrinting(pPedigree->likelihoodPolynomial);
//                fprintf(stderr,"\n");
	      pPedigree->likelihoodPolyList = buildPolyList ();
	      polyListSorting (pPedigree->likelihoodPolynomial,
			       pPedigree->likelihoodPolyList);
	      /* clean up polynomials that are not used in the final pedigree likelihood */
	      partialPolynomialClearance2 ();
	    }
	  /* evaluate likelihood */
	  pPedigree->likelihood =
	    evaluatePoly (pPedigree->likelihoodPolynomial,
			  pPedigree->likelihoodPolyList);

	}
      else
	{
	  initialize_multi_locus_genotype (pPedigree);
	  status = compute_pedigree_likelihood (pPedigree);
	}
#else
      initialize_multi_locus_genotype (pPedigree);
      status = compute_pedigree_likelihood (pPedigree);
#endif

      if (pPedigree->likelihood == 0.0)
	{
	  KLOG (LOGLIKELIHOOD, LOGWARNING,
		"Pedigree %s has likelihood of 0 or too small.\n",
		pPedigree->sPedigreeID);
	  fprintf (stderr,
		   "Pedigree %s has likelihood of 0 or too small.\n",
		   pPedigree->sPedigreeID);
	  product_likelihood = 0.0;
	  sum_log_likelihood = -9999.99;
	  break;
	}
      else if (pPedigree->likelihood < 0.0)
	{
	  KASSERT (pPedigree->likelihood >= 0.0,
		   "Pedigree %s with NEGATIVE likelihood - This is CRAZY!!!.\n",
		   pPedigree->sPedigreeID);
	  product_likelihood = 0.0;
	  sum_log_likelihood = -9999.99;
	  break;
	}
      else
	{
	  if (pPedigree->pCount[origLocus] == 1)
	    {
	      product_likelihood *= pPedigree->likelihood;
	      log10Likelihood = log10 (pPedigree->likelihood);
	    }
	  else
	    {
	      product_likelihood *=
		pow (pPedigree->likelihood, pPedigree->pCount[origLocus]);
	      log10Likelihood =
		log10 (pPedigree->likelihood) * pPedigree->pCount[origLocus];
	    }
	  /*
	     if(log10Likelihood <= __DBL_MIN_10_EXP__ + 1)
	     fprintf(stderr, "Pedigree %s has likelihood that's too small.\n",
	     pPedigree->sPedigreeID);
	   */
	  sum_log_likelihood += log10Likelihood;
	}
    }

  pPedigreeList->likelihood = product_likelihood;
  pPedigreeList->log10Likelihood = sum_log_likelihood;
  KLOG (LOGLIKELIHOOD, LOGDEBUG, "Sum of log Likelihood is: %e\n",
	sum_log_likelihood);

  return 0;
}

/* release polynomial for all pedigrees */
void
pedigreeSetPolynomialClearance (PedigreeSet * pPedigreeList)
{

#ifndef NO_POLYNOMIAL
  Pedigree *pPedigree;
  int i;

  if (modelOptions.polynomial == TRUE)
    {
      for (i = 0; i < pPedigreeList->numPedigree; i++)
	{
	  pPedigree = pPedigreeList->ppPedigreeSet[i];
	  if (pPedigree->likelihoodPolynomial != NULL)
	    {
	      pPedigree->likelihoodPolynomial = NULL;
	      free (pPedigree->likelihoodPolyList->pList);
	      free (pPedigree->likelihoodPolyList);
	      pPedigree->likelihoodPolyList = NULL;
	    }
	}
    }
#endif
}

/* compute likelihood for a given pedigree */
int
compute_pedigree_likelihood (Pedigree * pPedigree)
{
  int i;
  NuclearFamily *pNucFam; /* nuclear families within the pedigree */
  int status; /* function return status */
  Person *pProband; /* peeling proband */
  double likelihood;
#ifndef NO_POLYNOMIAL
  Polynomial *pLikelihoodPolynomial = NULL;
#endif

  /* initialize all the nuclear families before peeling starts
   * in many cases, multiple likelihoods are computed for the same family
   * with different parameters, we need to clean up before (or after) 
   * each calculation */
  for (i = 0; i < pPedigree->numNuclearFamily; i++)
    {
      pNucFam = pPedigree->ppNuclearFamilyList[i];
      pNucFam->doneFlag = 0;
    }

  /* peeling starts from the peeling proband and eventually will come back to 
   * the same proband 
   * this process will obtain the conditional likelihoods for the proband 
   */
  status = peel_graph (pPedigree->pPeelingNuclearFamily,
		       pPedigree->pPeelingProband,
		       pPedigree->peelingDirection);

  /* done peeling, need to add up the conditional likelihood for the leading peeling proband */
  pProband = pPedigree->pPeelingProband;
  likelihood = 0;
#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial == TRUE)
    pLikelihoodPolynomial = constantExp (0);
#endif

  /* loop over all conditional likelihoods */
  for (i = 0; i < pProband->numConditionals; i++)
    {
      /* Get the joint likelihood = marginal * p(G) 
       * when the proband is a founder, the weight will be the multilocus genotype probabilities
       * under LE or haplotype frequencies under LD
       * otherwise the weight should be 1
       *
       */
#ifndef NO_POLYNOMIAL
      if (modelOptions.polynomial == TRUE)
	{
	  /* build likelihood polynomial */
	  pLikelihoodPolynomial =
	    plusExp (2, 
		     1.0, 
		     pLikelihoodPolynomial,
		     1.0, 
		     timesExp (2,
			       pProband->pLikelihood[i].likelihoodPolynomial, 
			       1,
			       pProband->pLikelihood[i].weightPolynomial,
			       1, 
			       0), 
		     1);
	}
      else
	{
	  likelihood += pProband->pLikelihood[i].likelihood *
	    pProband->pLikelihood[i].weight;
	}
#else
      likelihood += pProband->pLikelihood[i].likelihood *
	pProband->pLikelihood[i].weight;
#endif
    } /* end of looping over all conditionals */

#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial == TRUE)
    /* save the polynomial to the pedigree structure */
    pPedigree->likelihoodPolynomial = pLikelihoodPolynomial;
  else
    /* save the likelihood in the pedigree structure */
    pPedigree->likelihood = likelihood;
#else
  pPedigree->likelihood = likelihood;
  KLOG (LOGLIKELIHOOD, LOGDEBUG, "log Likelihood for pedigree %d is: %e\n",
	pPedigree->pedigreeIndex + 1, log10 (likelihood));
#endif

  return 0;
}

/* recursive procedure to go through all nuclear families within one pedigree 
 * pNucFam -- input nuclear family, the top layer is the peeling nuclear family which 
 *            is the nuclear family contains the peeling proband 
 * pProband -- connector 
 * peelingDireciton -- UP/DOWN -- currently it is not used at all 
 */
int
peel_graph (NuclearFamily * pNucFam, Person * pProband, int peelingDirection)
{
  NuclearFamilyConnector *pConnector; /* connector structure which represents connector 
					 from one nuc to the other within a pedigree */
  NuclearFamily *pNucFam2; /* another nuc family input nuc family is connected to */
  Person *pConnectPerson; /* connector individual */
  int i;

  /* if this nuclear family has been processed or in the middle of process, skip it */
  if (pNucFam->doneFlag == TRUE)
    return 0;

  /* mark this nuclear family as done to avoid potential endless recurisve calls */
  pNucFam->doneFlag = TRUE;

  /* go up through the connectors if any */
  pConnector = pNucFam->pUpConnectors;
  while (pConnector)
    {
      pNucFam2 = pConnector->pConnectedNuclearFamily;
      pConnectPerson = pConnector->pConnectedPerson;
      if (pConnectPerson == pNucFam2->pParents[DAD] ||
	  pConnectPerson == pNucFam2->pParents[MOM])
	{
	  /* these two families are connected through multiple marraige */
	  peel_graph (pConnector->pConnectedNuclearFamily,
		      pConnector->pConnectedPerson, PEDIGREE_UP);
	}
      else
	{
	  peel_graph (pConnector->pConnectedNuclearFamily,
		      pConnector->pConnectedPerson, PEDIGREE_DOWN);
	}
      pConnector = pConnector->pNextConnector;
    }

  /* go down through the down connectors if any */
  pConnector = pNucFam->pDownConnectors;
  while (pConnector)
    {
      /* peel up to the proband */
      peel_graph (pConnector->pConnectedNuclearFamily, pConnector->pConnectedPerson, PEDIGREE_UP);

      pConnector = pConnector->pNextConnector;
    }

  /* we are done with the up or down linked nuclear families or we are a leave
   * or top. ready for likelihood computation for this nuclear family 
   * save the original genotype list first 
   * during likelihood calculation, we limit the child proband's genotype to one at a time
   * once done, the original list will be copied back
   */
  memcpy (&pProband->ppSavedGenotypeList[0],
	  &pProband->ppGenotypeList[0],
	  sizeof (Genotype *) * originalLocusList.numLocus);
  memcpy (&pProband->pSavedNumGenotype[0],
	  &pProband->pNumGenotype[0],
	  sizeof (int) * originalLocusList.numLocus);

  KLOG (LOGPARENTALPAIR, LOGDEBUG, "\t Proband (%s) haplotype: \n",
	pProband->sID);
  if (pProband->ppHaplotype == NULL)
    {
      /* allocate space for storing proband's haplotype if not already done */
      pProband->ppHaplotype = MALLOC ("pProband->ppHaplotype",
				      sizeof (Genotype *) * sizeof (int) *
				      originalLocusList.numLocus);
    }

#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial == TRUE)
    {
      if (pNucFam->pParents[DAD] != pProband
	  && pNucFam->pParents[MOM] != pProband)
	{
	  /* child is the proband 
	   * construct all possible multilocus genotype for the proband
	   * for each of them, calculate the conditional likelihood of the nuclear family
	  */
	  loop_child_proband_genotype (pNucFam, pProband, peelingDirection, 0, 0);
	}
      else
	{
	  /* parent is the proband */
	  compute_nuclear_family_likelihood (pNucFam, pProband, peelingDirection);
	}
    }
  else /* PE is not enabled */
    {
      if (pNucFam->pParents[DAD] != pProband
	  && pNucFam->pParents[MOM] != pProband)
	{
	  /* child is the proband 
	   * construct all possible multilocus genotype for the proband
	   * for each of them, calculate the conditional likelihood of the nuclear family
	   */
	  loop_child_proband_genotype (pNucFam, pProband, peelingDirection, 0, 0);
	}
      else
	{
	  /* parent is the proband */
	  compute_nuclear_family_likelihood (pNucFam, pProband, peelingDirection);
	  /* copy the temporary results back */
	  for (i = 0; i < pProband->numConditionals; i++)
	    {
	      pProband->pLikelihood[i].likelihood = pProband->pLikelihood[i].tmpLikelihood;
	      pProband->pLikelihood[i].likelihoodPolynomial = 
		pProband->pLikelihood[i].tmpLikelihoodPolynomial;
	    }
	}
    }
#else /* PE is not even compiled in */
  if (pNucFam->pParents[DAD] != pProband
      && pNucFam->pParents[MOM] != pProband)
    {
      /* child is the proband 
       * construct all possible multilocus genotype for the proband
       * for each of them, calculate the conditional likelihood of the nuclear family
       */
      loop_child_proband_genotype (pNucFam, pProband, peelingDirection, 0, 0);
    }
  else
    {
      /* parent is the proband */
      compute_nuclear_family_likelihood (pNucFam, pProband, peelingDirection);
      /* copy the temporary results back */
      for (i = 0; i < pProband->numConditionals; i++)
	{
	  pProband->pLikelihood[i].likelihood = pProband->pLikelihood[i].tmpLikelihood;
	  pProband->pLikelihood[i].likelihoodPolynomial = 
	    pProband->pLikelihood[i].tmpLikelihoodPolynomial;
	}
    }
#endif

  /* mark the proband as been touched - we have done some likelihood calculation on this person */
  pProband->touchedFlag = 1;

  /* copy back the genotypes for the proband */
  memcpy (&pProband->ppGenotypeList[0],
	  &pProband->ppSavedGenotypeList[0],
	  sizeof (Genotype *) * originalLocusList.numLocus);
  memcpy (&pProband->pNumGenotype[0],
	  &pProband->pSavedNumGenotype[0],
	  sizeof (int) * originalLocusList.numLocus);


  return 0;
}

/* This function loops over child proband's multilocus genotypes recursively and 
 * calls compute_nuclear_family_likelihood for each multilocus genotype 
 * pNucFam - the nuclear family we are working on 
 * locus - current working locus 
 * multiLocusIndex - index to the flattened array of conditional likelihood for the proband
 */
int
loop_child_proband_genotype (NuclearFamily * pNucFam, 
			     Person * pProband,
			     int peelingDirection, 
			     int locus,
			     int multiLocusIndex)
{
  int origLocus = locusList->pLocusIndex[locus]; /* locus index in the original locus list */
  Genotype *pGenotype;
  int position;	/* genotype position */
  Genotype *pNextGenotype;
  int numGenotype; /* number of possible genotypes for this proband at this locus */
  int multiLocusIndex2;
  int traitOrigLocus;

  double penetrance = 1;
#ifndef NO_POLYNOMIAL
  Polynomial *penetrancePolynomial = NULL;
#endif

  /* we loop over the genotypes of the proband to condition the 
   * likelihood calculation on it */
  numGenotype = pProband->pSavedNumGenotype[origLocus];
  /* calculate the flattened conditional likelihood array index */
  multiLocusIndex2 = multiLocusIndex * numGenotype;
  pGenotype = pProband->ppSavedGenotypeList[origLocus];
  while (pGenotype != NULL)
    {
      /* record this locus's genotype in the haplotype structure - it's really just phased
       * multilocus genotype (not single chromosome haplotype)
       * genotype is stored in the order of the original locus order
       */
      pProband->ppHaplotype[origLocus] = pGenotype;
      KLOG (LOGPARENTALPAIR, LOGDEBUG, "\t\t\t %d|%d \n",
	    pGenotype->allele[DAD], pGenotype->allele[MOM]);
      /* temporarilly set the next pointer to NULL so to restrict
       * the genotype on the proband to current genotype only */
      pProband->ppGenotypeList[origLocus] = pGenotype;
      pNextGenotype = pGenotype->pNext;
      pGenotype->pNext = NULL;
      pProband->pNumGenotype[origLocus] = 1;
      position = pGenotype->position;
      /* calculate the flattened conditional likelihood array index */
      multiLocusIndex = multiLocusIndex2 + position;

      if (locus < locusList->numLocus - 1)
	{
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      loop_child_proband_genotype (pNucFam, pProband,
					   peelingDirection, locus + 1,
					   multiLocusIndex);
	    }
	  else
	    {
	      loop_child_proband_genotype (pNucFam, pProband,
					   peelingDirection, locus + 1,
					   multiLocusIndex);
	    }
#else
	  loop_child_proband_genotype (pNucFam, pProband, peelingDirection,
				       locus + 1, multiLocusIndex);
#endif
	}
      else
	{
	  /* we have got the entire multi-locus genotype for the proband */
	  compute_nuclear_family_likelihood (pNucFam, pProband, peelingDirection);
	  /* store the likelihood in the corresponding flattened array */
	  if (pProband->pLikelihood[multiLocusIndex].touchedFlag == FALSE)
	    {
	      pProband->pLikelihood[multiLocusIndex].touchedFlag = TRUE;
	      /* if trait locus exists, we need to retrieve the penetrance */
	      if (locusList->traitLocusIndex >= 0)
		{
		  traitOrigLocus =
		    locusList->pLocusIndex[locusList->traitLocusIndex];
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      penetrancePolynomial =
			pProband->ppHaplotype[traitOrigLocus]->penetrancePolynomial;
		    }
		  else
		    {
		      penetrance =
			pProband->ppHaplotype[traitOrigLocus]->penetrance;
		    }
#else
		  penetrance =
		    pProband->ppHaplotype[traitOrigLocus]->penetrance;
#endif
		}
	      else		/* no trait locus */
		{
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      penetrancePolynomial = constantExp (1);
		    }
		  else
		    {
		      penetrance = 1;
		    }
#else
		  penetrance = 1;
#endif
		}		/* no trait locus */

#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  pProband->pLikelihood[multiLocusIndex].
		    likelihoodPolynomial =
		    timesExp (2, penetrancePolynomial, 1,
			      pNucFam->likelihoodPolynomial, 1, 1);

		  /* for a child, the weight should be 1 */
		  pProband->pLikelihood[multiLocusIndex].weightPolynomial =
		    constantExp (1);
		}
	      else
		{
		  /* need to update the penetrance factors */
		  pProband->pLikelihood[multiLocusIndex].likelihood =
		    penetrance * pNucFam->likelihood;
		  /* for a child, the weight should be 1 */
		  pProband->pLikelihood[multiLocusIndex].weight = 1;
		}
#else
	      /* need to update the penetrance factors */
	      pProband->pLikelihood[multiLocusIndex].likelihood =
		penetrance * pNucFam->likelihood;
	      /* for a child, the weight should be 1 */
	      pProband->pLikelihood[multiLocusIndex].weight = 1;
#endif
	    }	/* first time updating the likelihood for this phased multilocus genotype */
	  else	/* NOT first time updating the likelihood for this phased multilocus genotypes */
	    {
	      /* no need to consider penetrance anymore */
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  pProband->pLikelihood[multiLocusIndex].likelihoodPolynomial =
		    timesExp (2,
			      pProband->pLikelihood[multiLocusIndex].
			      likelihoodPolynomial, 1,
			      pNucFam->likelihoodPolynomial, 1, 1);
		  //fprintf(stderr,"Likelihood for this entire multi-locus genotype %f %f\n",
		  //evaluateValue(pNucFam->likelihoodPolynomial),
		  //evaluateValue(pProband->pLikelihood[multiLocusIndex].likelihoodPolynomial));
		}
	      else
		{
		  pProband->pLikelihood[multiLocusIndex].likelihood *=
		    pNucFam->likelihood;
		  /*  fprintf (stderr,
		     "Likelihood for this entire multi-locus genotype %f %f\n",
		     pNucFam->likelihood,
		     pProband->pLikelihood[multiLocusIndex].likelihood);
		   */
		}
#else
	      pProband->pLikelihood[multiLocusIndex].likelihood *=
		pNucFam->likelihood;
#endif
	    }
	} /* end of processing complete child multilocus genotype  */
      /*when we are done, need to restore the genotype link list pointer */
      pGenotype->pNext = pNextGenotype;
      pGenotype = pNextGenotype;
    }	/* loop over all possible genotypes */

  return 0;
}

/* for now, we only use parental pair algorithm 
 * This function goes through all possible parental pairs, for each parental pair, it 
 * calculates likelihood
 */
int
compute_nuclear_family_likelihood (NuclearFamily * pNucFam,
				   Person * pProband, int peelingDirection)
{
  int locus; /* locus index to construct parental pairs */
  double weight[2] = { 1, 1 }; /* weight for the two parents */
#ifndef NO_POLYNOMIAL
  /* need to define some terms for the polynomail operations */
  Polynomial *weightPolynomial[2];
#endif
  int multiLocusIndex[2] = { 0, 0 }; /* proband's conditional likelihood offset */

  int numHaplotypePair = 1; /* number of multilocus genotypes */
  int numChild; /* number of children in this nuclear family */
  int i, j;

  /* initialize the weight for each parent */
#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial == TRUE)
    {
      weightPolynomial[0] = constantExp (1);
      weightPolynomial[1] = constantExp (1);
      pNucFam->likelihoodPolynomial = constantExp(0);
    }
#endif
  pNucFam->likelihood = 0;

  /* the following is to help to set the order which parent's genotype to flip first */
  if (pProband == pNucFam->pParents[MOM])
    {
      /* MOM is the proband */
      pNucFam->head = MOM;
      pNucFam->spouse = DAD;
    }
  else
    {
      /* either DAD is the proband or the child is the proband */
      pNucFam->head = DAD;
      pNucFam->spouse = MOM;
    }

  numChild = pNucFam->numChildren;

  /* first construct the parental pair for this nuclear family locus
   * by locus */
  numHaplotypePair = 1;
  for (locus = 0; locus < locusList->numLocus; locus++)
    {
      /* construct parental pair locus by locus */
      construct_parental_pair (pNucFam, pProband, locus);
      /* calculate number of possible multilocus genotypes */
      numHaplotypePair *= parentalPairSpace.pNumParentalPair[locus];
    }

  for(i=DAD; i<=MOM; i++)
    {
      pNucFam->numHetLocus[i] = 0;
      pNucFam->firstHetLocus[i] = -1;
      for(j=0; j < locusList->numLocus; j++)
	pNucFam->hetFlag[i][j] = 0;
    }
      
  /* now we can construct haplotypes and get likelihood computed */
  KLOG (LOGPARENTALPAIR, LOGDEBUG, "Haplotype for nuclear family No. %d:\n",
	pNucFam->nuclearFamilyIndex);
  KLOG (LOGPARENTALPAIR, LOGDEBUG, "\t\t\t DAD(%s)\t\t\t MOM(%s)\n",
	pNucFam->pParents[DAD]->sID, pNucFam->pParents[MOM]->sID);
  /* recursively call loop_parental_pair to get a complete multlocus genotype */
#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial == TRUE)
    {
      loop_parental_pair (pNucFam, pProband, 0, &parentalPairSpace,
			  multiLocusIndex, (void *) weightPolynomial);
//      fprintf(stderr,"Conditional likelihood for nuclear family %d is: %e\n",
//            pNucFam->nuclearFamilyIndex, evaluateValue(sumPolynomial));
    }
  else
    {
      loop_parental_pair (pNucFam, pProband, 0, &parentalPairSpace,
			  multiLocusIndex, (void *) weight);
      /*
      KLOG (LOGLIKELIHOOD, LOGDEBUG,
	    "Conditional likelihood for nuclear family %d is: %e\n",
	    pNucFam->nuclearFamilyIndex, sum);
      */
    }
#else
  loop_parental_pair (pNucFam, pProband, 0, &parentalPairSpace,
		      multiLocusIndex, (void *) weight);
  /*
  KLOG (LOGLIKELIHOOD, LOGDEBUG,
	"Conditional likelihood for nuclear family %d is: %e\n",
	pNucFam->nuclearFamilyIndex, sum);
  */
#endif

  return 0;
}

/* using the parental pair algorithm to go through all possible 
 * parental pairs and calculate the likelihood of each parental pair 
 * nested looping is for the multi-locus */
int
loop_parental_pair (NuclearFamily * pNucFam,
		    Person * pProband,
		    int locus,
		    ParentalPairSpace * pHaplo,
		    int multiLocusIndex[2],
		    void *dWeight[2])
{
  ParentalPair *pPair; /* parental pair for current locus */
  int origLocus; /* locus index in the original locus list */
  int i, j, k;
  int multiLocusIndex2[2]; 
  Person *pParent[2]; /* two parents */
  int numGenotype[2]; /* number of genotypes at this locus */
  int numPair; /* index to the list of parental pairs */
  double newWeight[2]; /* genotype weight */
#ifndef NO_POLYNOMIAL
  Polynomial *newWeightPolynomial[2];
#endif
  int head;  /* proband if no child is a proband, otherwise DAD  */
  int spouse; /* spouse of the head */
  int likelihoodIndex; /* likelihood index for the proband */
  int multiLocusPhase[2] = { 0, 0 }; /* index to the related parental pair matrix */

  head = pNucFam->head;
  spouse = pNucFam->spouse;

  origLocus = locusList->pLocusIndex[locus];
  for (i = DAD; i <= MOM; i++)
    {
      newWeight[i] = *(double *) dWeight[i];
#ifndef NO_POLYNOMIAL 
      newWeightPolynomial[i] = (Polynomial *) dWeight[i];
#endif
      pParent[i] = pNucFam->pParents[i];
      /* find the max number of possible genotypes for this parent */
      numGenotype[i] = pNucFam->pParents[i]->pSavedNumGenotype[origLocus];
      /* calculate this parent's conditional likelihood's offset */
      multiLocusIndex2[i] = multiLocusIndex[i] * numGenotype[i];
    }
  /* parental pair index for this locus */
  numPair = -1;
  while ((numPair + 1) < pHaplo->pNumParentalPair[locus])
    {
      /* find related parental pairs */
      numPair++;
      /* get the parental pair */
      pPair = &pHaplo->ppParentalPair[locus][numPair];
      /* set the het flag */
      for(i=DAD; i <= MOM; i++)
	{
	  if(locus==0)
	    {
	      /* initialize when we come back to first locus */
	      pNucFam->firstHetLocus[i] = -1;
	      pNucFam->tmpNumHet[i][0] = 0;
	    }
	  else
	    pNucFam->tmpNumHet[i][locus] = pNucFam->tmpNumHet[i][locus-1];
	  if(isHet(pPair->pGenotype[i]))
	    {
	      pNucFam->hetFlag[i][locus] = 1;
	      if(pNucFam->firstHetLocus[i] == -1)
		pNucFam->firstHetLocus[i] = locus;
	      pNucFam->tmpNumHet[i][locus]++;
	    }
	  else
	    pNucFam->hetFlag[i][locus] = 0;
	}
      /* record the start of the related parental pairs for this locus */
      pNucFam->relatedPPairStart[locus] = numPair;
      pNucFam->numRelatedPPair[locus] = 1;
      /* find the related parental pairs that have same pair of genotypes only differ in phases */
      while ((numPair + 1) < pHaplo->pNumParentalPair[locus] &&
	     (pHaplo->ppParentalPair[locus][numPair + 1].phase[DAD] > 0 ||
	      pHaplo->ppParentalPair[locus][numPair + 1].phase[MOM] > 0))
	{
	  numPair++;
	  pNucFam->numRelatedPPair[locus]++;
	}

      for (i = DAD; i <= MOM; i++)
	{
	  /* calculate each parent's conditional likelihood offset base on the current genotype */
	  multiLocusIndex[i] =
	    multiLocusIndex2[i] + pPair->pGenotype[i]->position;
	  if (modelOptions.equilibrium == LINKAGE_EQUILIBRIUM
	      && pNucFam->pParents[i]->pParents[DAD] == NULL)
	    {
	      /* 
	       * For founders:
	       *   under LE, we just multiply the founder weights, 
	       *   under LD, we need to use haplotype freq - which we will do in loop_phases
	       * For non-founders, we don't even care, they should remain as 1 as initialized
	       */
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  newWeightPolynomial[i] =
		    timesExp (2, newWeightPolynomial[i], 1,
			      pPair->pGenotype[i]->weightPolynomial, 1, 0);
		}
	      else
		{
		  newWeight[i] *=  pPair->pGenotype[i]->weight;
		}
#else
	      newWeight[i] *= pPair->pGenotype[i]->weight;
#endif
	    }
	}			/* looping dad and mom genotypes */


      if (locus < locusList->numLocus - 1)
	{
	  /* recursively calling this function to get a complete multilocus genotype */
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {

	      loop_parental_pair (pNucFam, pProband, locus + 1, pHaplo,
				  multiLocusIndex,
				  (void *) newWeightPolynomial);
	    }
	  else
	    {
	      loop_parental_pair (pNucFam, pProband, locus + 1, pHaplo,
				  multiLocusIndex,
				  (void *) newWeight);
	    }
#else
	  loop_parental_pair (pNucFam, pProband, locus + 1, pHaplo,
			      multiLocusIndex,
			      (void *) newWeight);
#endif
	}
      else	  /* got a complete set of parental pairs */
	{
	  /* initialize the phase matrix */
	  memset(ppairMatrix, 0, ppairMatrixSize);
	  
	  /* set some information */
	  pNucFam->numHetLocus[head] = pNucFam->tmpNumHet[head][locus];
	  pNucFam->numHetLocus[spouse] = pNucFam->tmpNumHet[spouse][locus];
	  /* set bit mask - all bits set to 1 - number of bits == number of het loci */
	  pNucFam->hetLocusBits[head] = pow(2, pNucFam->numHetLocus[head]) - 1;
	  pNucFam->hetLocusBits[spouse] = pow(2, pNucFam->numHetLocus[spouse]) -1; 
	   
#ifndef NO_POLYNOMIAL
	  if(modelOptions.polynomial == TRUE)
	    loop_phases (pNucFam, pHaplo, pProband, 0, multiLocusIndex,
			 multiLocusPhase, (void *)newWeightPolynomial);
	  else
	    loop_phases (pNucFam, pHaplo, pProband, 0, multiLocusIndex,
			 multiLocusPhase, (void *)newWeight);
#else
	  loop_phases (pNucFam, pHaplo, pProband, 0, multiLocusIndex,
		       multiLocusPhase, (void *)newWeight);
#endif

	  /* post processing of results of similar parental pairs and store them 
	   * in the proband's likelihood space */
	  if (pProband != pNucFam->pParents[DAD]
	      && pProband != pNucFam->pParents[MOM])
	    {
	      /* child is the proband, sum likelihood across all rows and columns  
	       * save it at the tmpLikelihood
	       */
	      for (j = 0; j < pNucFam->numHetLocus[head]; j++)
		{
		  for (k = 0; k < pNucFam->numHetLocus[spouse]; k++)
		    {
		      if (ppairMatrix[j][k].count > 1)
			{
#ifndef NO_POLYNOMIAL
			  if(modelOptions.polynomial == TRUE)
			    {
			      pNucFam->likelihoodPolynomial=
				plusExp(2, 
					1.0, 
					pNucFam->likelihoodPolynomial,
					1.0, 
					timesExp(2, 
						 ppairMatrix[j][k].slot.likelihoodPolynomial, 
						 1, 
						 constantExp(ppairMatrix[j][k].count), 
						 1, 
						 0),
					1);
			    }
			  else
			    pNucFam->likelihood += 
			      ppairMatrix[j][k].slot.likelihood * ppairMatrix[j][k].count;
#else
			  pNucFam->likelihood += 
			    ppairMatrix[j][k].slot.likelihood * ppairMatrix[j][k].count;
#endif
			}
		      else if (ppairMatrix[j][k].count > 0) /* count == 1 */
			{
#ifndef NO_POLYNOMIAL
			  if(modelOptions.polynomial == TRUE)
			    {
			      pNucFam->likelihoodPolynomial=
				plusExp(2, 
					1.0, 
					pNucFam->likelihoodPolynomial,
					1.0, 
					ppairMatrix[j][k].slot.likelihoodPolynomial, 
					1);
			    }
			  else
			    pNucFam->likelihood += 
			      ppairMatrix[j][k].slot.likelihood;
#else
			  pNucFam->likelihood += 
			    ppairMatrix[j][k].slot.likelihood;
#endif
			}
		    }
		}
	    }
	  else
	    {	      /* one of the parent is the proband */
	      for (j = 0; j < pNucFam->numHetLocus[head]; j++)
		{
		  /* get the proband's conditional likelihood index for this row
		   * sum up across this row and save them to the proband's likelihood storage
		   */
		  likelihoodIndex = ppairMatrix[j][0].likelihoodIndex;
		  for (k = 0; k < pNucFam->numHetLocus[spouse]; k++)
		    {
		      if (ppairMatrix[j][k].count > 1)
			{
#ifndef NO_POLYNOMIAL
			  if(modelOptions.polynomial == TRUE)
			    {
			      pProband->pLikelihood[likelihoodIndex].tmpLikelihoodPolynomial=
				plusExp(2, 
					1.0, 
					pProband->pLikelihood[likelihoodIndex].tmpLikelihoodPolynomial,
					1.0, 
					timesExp(2, 
						 ppairMatrix[j][k].slot.likelihoodPolynomial, 
						 1, 
						 constantExp(ppairMatrix[j][k].count), 
						 1, 
						 0),
					1);
			    }
			  else
			    pProband->pLikelihood[likelihoodIndex].tmpLikelihood += 
			      ppairMatrix[j][k].slot.likelihood * ppairMatrix[j][k].count;
#else
			  pProband->pLikelihood[likelihoodIndex].tmpLikelihood += 
			    ppairMatrix[j][k].slot.likelihood * ppairMatrix[j][k].count;
#endif
			} /* count > 1 */
		      else if (ppairMatrix[j][k].count > 0)
			{
#ifndef NO_POLYNOMIAL
			  if(modelOptions.polynomial == TRUE)
			    {
			      pProband->pLikelihood[likelihoodIndex].tmpLikelihoodPolynomial=
				plusExp(2, 
					1.0, 
					pProband->pLikelihood[likelihoodIndex].tmpLikelihoodPolynomial,
					1.0, 
					ppairMatrix[j][k].slot.likelihoodPolynomial, 
					1);
			    }
			  else
			    pProband->pLikelihood[likelihoodIndex].tmpLikelihood += 
			      ppairMatrix[j][k].slot.likelihood;
#else
			  pProband->pLikelihood[likelihoodIndex].tmpLikelihood += 
			    ppairMatrix[j][k].slot.likelihood;
#endif
			} /* count > 0 */
		    } /* loop through column */
		} /* loop through row */
	    } /* one parent is proband */
	} /* end of processing one parental pair */
      numPair++;	/* move to next parental pair */
    }

  return 0;
}



/* Compute likelihood for parental multilocus genotypes pairs that are only different in phases 
 * Input: parental pairs for this nuclear family
 *        parental pairs with different phases are next to each other
 *        weight - genotype weights for the parental genotypes 
 *                 LE:
 *                   founder - phase doesn't matter
 *                   non-founder - phase will come to play
 *                 LD: 
 *                   phase matters for both founders and non-founders
 *        penetrance - is not an input as it can be different for different phases if we consider
 *                     imprinting effect
 *                     penetrance only applies to disease locus if it's included in the list 
*/
void
loop_phases (NuclearFamily * pNucFam, ParentalPairSpace * pHaplo,
	     Person * pProband, int locus, int multiLocusIndex[2],
	     int multiLocusPhase[2], void *dWeight[2])
{
  /* conditional likelihood index for each parent */
  int multiLocusIndex2[2];
  /* index to related parental pair matrix */
  int multiLocusPhase2[2];
  /* index of the flip of current pattern in related parental pair matrix */
  int multiLocusPhaseFlip[2];
  Person *pParent[2];
  int numGenotype[2];
  int i;
  int numPair;
  int origLocus = locusList->pLocusIndex[locus];   /* locus index in the original locus list */
  ParentalPair *pPair;
  /* whether a fresh calculation is needed or we could find existing pattern result */
  int calculateFlag;
  int phase[2];
  int proband;
  int spouse;
  double freq;
  double newWeight[2];
  double sum;
  int child;
  int xmissionIndex[2];
  double childProduct;
#ifndef NO_POlYNOMIAL
  Polynomial *freqPolynomial;
  Polynomial *newWeightPolynomial[2];
  Polynomial *sumPolynomial;
  Polynomial *childProductPolynomial = NULL;
#endif

  for (i = DAD; i <= MOM; i++)
    {
      pParent[i] = pNucFam->pParents[i];
      /* find the max number of possible genotypes for this parent */
      numGenotype[i] = pNucFam->pParents[i]->pSavedNumGenotype[origLocus];
      /* likelihood storage index */
      multiLocusIndex2[i] = multiLocusIndex[i] * numGenotype[i];
      if (pNucFam->hetFlag[locus][i] == 1)
	{
	  /* phase combination index */
	  multiLocusPhase2[i] = multiLocusPhase[i] * 2;
	}
      else
	{
	  multiLocusPhase2[i] = multiLocusPhase[i];
	}
    }

  proband = pNucFam->head;
  spouse = pNucFam->spouse;
  /* get the start of the related pair */
  numPair = pNucFam->relatedPPairStart[locus] - 1;
  while ((numPair += 1) < pNucFam->numRelatedPPair[locus])
    {
      pPair = &pHaplo->ppParentalPair[locus][numPair];
      pHaplo->pParentalPairInd[locus] = numPair;
      pHaplo->phase[i][locus] = pPair->phase[i];
      multiLocusPhase[i] = multiLocusPhase2[i] + pPair->phase[i];
      if (locus < locusList->numLocus - 1)
	{
	  multiLocusIndex[i] =
	    multiLocusIndex2[i] + pPair->pGenotype[i]->position;
	  loop_phases (pNucFam, pHaplo, pProband, locus + 1, multiLocusIndex,
		       multiLocusPhase, dWeight);
	}
      else	  /* got a complete multilocus parental pair */
	{
	  calculateFlag = 1;
	  if (pProband != pNucFam->pParents[DAD]
	      && pProband != pNucFam->pParents[MOM])
	    {
	      /* child is the proband */
	      for (i = DAD; i <= MOM; i++)
		{
		  phase[i] = multiLocusPhase[i];
		  if (pHaplo->phase[i][pNucFam->firstHetLocus[i]] != 0)
		    {
		      /* first het locus has a reverse phase than the origninal 
		       * potentially we could benefit from directly using the likelihood calculated 
		       * with different phase
		       */
		      /* if this parent is a founder or a proband, then flip==original */
		      if (pNucFam->pParents[i]->pParents[DAD] == NULL)
			{
			  multiLocusPhaseFlip[i] =
			    ~multiLocusPhase[i] & pNucFam->hetLocusBits[i];
			  phase[i] = multiLocusPhaseFlip[i];
			  calculateFlag = 0;
			}
		    }
		}
	      if (calculateFlag == 0)
		{
		  ppairMatrix[phase[proband]][phase[spouse]].count++;
		}
	    }			/* a child is the proband */
	  else
	    {
	      /* one parent is proband */
	      if (pHaplo->phase[spouse][pNucFam->firstHetLocus[spouse]] != 0)
		{
		  if (pNucFam->pParents[spouse]->pParents[DAD] == NULL)
		    {
		      /* non-proband parent is a founder */
		      /* find the reverse pattern */
		      multiLocusPhaseFlip[spouse] =
			~multiLocusPhase[spouse] & pNucFam->hetLocusBits[spouse];
		      /* increase the count on the original  */
		      ppairMatrix[multiLocusPhase[proband]]
				  [multiLocusPhase[spouse]].count++;
		    }
		  else
		    calculateFlag = 1;
		}
	      if (pHaplo->phase[proband][pNucFam->firstHetLocus[proband]] != 0)
		{
		  /* find the reverse pattern */
		  multiLocusPhaseFlip[proband] =
		    ~multiLocusPhase[proband] & pNucFam->hetLocusBits[proband];
		  ppairMatrix[multiLocusPhaseFlip[proband]]
		    [multiLocusPhase[spouse]].slot.likelihood = ppairMatrix[1][1].slot.likelihood;
#ifndef NO_POLYNOMIAL
		  ppairMatrix[multiLocusPhaseFlip[proband]]
		    [multiLocusPhase[spouse]].slot.likelihoodPolynomial = 
		    ppairMatrix[1][1].slot.likelihoodPolynomial;
#endif
		}


	      if (calculateFlag == 1)
		{
		  for (i = DAD; i <= MOM; i++)
		    {
		      if (pNucFam->pParents[i] != pProband)
			{
			  if (pNucFam->pParents[i]->pParents[DAD] == NULL)
			    {
			      /* this parent is a founder and not a proband . the weight is just the multiplication of 
			         genotype weights at each locus under LE. The weight should have been passed 
			         in as an input */
			      if (modelOptions.equilibrium == LINKAGE_EQUILIBRIUM)
				{
#ifndef NO_POLYNOMIAL
				  
				  if(modelOptions.polynomial == TRUE)
				    newWeightPolynomial[i] = (Polynomial *) (dWeight+i);
				  else
				    newWeight[i] = *((double *) dWeight + i);
#else
				  newWeight[i] = *((double *) dWeight + i);
#endif
				}
			      else
				{
				  /* a founder, but not proband, use haplotype frequency instead */
#ifndef NO_POlYNOMIAL
				  if (modelOptions.polynomial == TRUE)
				    {

				      get_haplotype_freq (locus, i,
							  &freqPolynomial,
							  pHaplo);
				      newWeightPolynomial[i] = freqPolynomial;
				    }
				  else
				    {
				      get_haplotype_freq (locus, i, &freq, pHaplo);
				      newWeight[i] = freq;
				    }
#else
				  get_haplotype_freq (locus, i, &freq, pHaplo);
				  newWeight[i] = freq;
#endif
				}
			      /* need to multiply the penetrance if disease locus is in */
			      if (locusList->traitLocusIndex >= 0)
				{
#ifndef NO_POLYNOMIAL
				  if(modelOptions.polynomial == TRUE)
				    newWeightPolynomial[i] =
				      timesExp(2, 
					       newWeightPolynomial[i], 
					       1, 
					       pHaplo->ppParentalPair[locusList->traitLocusIndex]
					       [pHaplo->pParentalPairInd[locusList->traitLocusIndex]].
					       pGenotype[i]->penetrancePolynomial,
					       1, 
					       1); 
				  else
				    newWeight[i] *=
				      pHaplo->ppParentalPair[locusList->traitLocusIndex]
				      [pHaplo->pParentalPairInd[locusList->traitLocusIndex]].
				      pGenotype[i]->penetrance;
#else
				  newWeight[i] *=
				    pHaplo->ppParentalPair[locusList->traitLocusIndex]
				    [pHaplo->pParentalPairInd[locusList->traitLocusIndex]].
				    pGenotype[i]->penetrance;
#endif
				}
			    } /* founder, not proband */
			  else
			    {
			      /* this parent is not a founder. the weight should just be the likelihood
			         we have already calculated before (we must have, otherwise we can't even
			         process this nuclear family
			         Also the penetrance should have been included in the previous likelihood
			         calculation already
			       */
#ifndef NO_POLYNOMIAL
			      if(modelOptions.polynomial == TRUE)
				newWeightPolynomial[i] = 
				  pNucFam->pParents[i]->
				  pLikelihood[multiLocusIndex[i]].likelihoodPolynomial;
			      else
				newWeight[i] =
				  pNucFam->pParents[i]->
				  pLikelihood[multiLocusIndex[i]].likelihood;
#else
			      newWeight[i] =
				pNucFam->pParents[i]->
				pLikelihood[multiLocusIndex[i]].likelihood;
#endif
			    }
			}	/* parent is not a proband */
		      else
			{
			  /* proband parent - we don't do the weights until later */
#ifndef NO_POLYNOMIAL
			  if(modelOptions.polynomial == TRUE)
			    newWeightPolynomial[i] = constantExp(1);
			  else
			    newWeight[i] = 1;
#else
			  newWeight[i] = 1;
#endif
			}
		    }		/* loop over each parent */

		  /* now work on the children conditional on this parental pair */
		  childProduct = 1;
#ifndef NO_POLYNOMIAL
		  if(modelOptions.polynomial == TRUE)
		    childProductPolynomial = constantExp(1);
#endif
		  for (child = 0; child < pNucFam->numChildren; child++)
		    {
		      xmissionIndex[DAD] = 0;
		      xmissionIndex[MOM] = 0;

#ifndef NO_POLYNOMIAL
		      if(modelOptions.polynomial == TRUE)
			{
			  sumPolynomial = constantExp(0.0);
			  loop_child_multi_locus_genotype (pNucFam->
							   ppChildrenList[child],
							   pProband, pHaplo,
							   child, 0, 0,
							   &sumPolynomial,
							   xmissionIndex);
			  childProductPolynomial = 
			    timesExp(2, 
				     childProductPolynomial, 
				     1, 
				     sumPolynomial, 
				     1, 
				     1);
			}
		      else
			{
			  sum = 0;
			  loop_child_multi_locus_genotype (pNucFam->
							   ppChildrenList[child],
							   pProband, pHaplo,
							   child, 0, 0,
							   &sum,
							   xmissionIndex);
			  
			  childProduct *= sum;
			}
#else
		      sum = 0;
		      loop_child_multi_locus_genotype (pNucFam->
						       ppChildrenList[child],
						       pProband, pHaplo,
						       child, 0, 0,
						       &sum,
						       xmissionIndex);

		      childProduct *= sum;
#endif
		    } /* looping over all children */
		  ppairMatrix[multiLocusPhase[proband]]
		    [multiLocusPhase[spouse]].likelihoodIndex = multiLocusIndex[proband];
#ifndef NO_POLYNOMIAL
		  if(modelOptions.polynomial == TRUE)
		    {
		      ppairMatrix[multiLocusPhase[proband]]
			[multiLocusPhase[spouse]].slot.likelihoodPolynomial = 
			timesExp(3, 
				 newWeightPolynomial[DAD], 
				 1, 
				 newWeightPolynomial[MOM], 
				 1, 
				 childProductPolynomial,
				 1, 
				 0
				 );
		    }
		  else
		    {
		      /* save it */
		      ppairMatrix[multiLocusPhase[proband]]
			[multiLocusPhase[spouse]].slot.likelihood =
			newWeight[DAD] * newWeight[MOM] * childProduct;
		    }
#else
		  /* save it */
		  ppairMatrix[multiLocusPhase[proband]]
		    [multiLocusPhase[spouse]].slot.likelihood = 
		    newWeight[DAD] * newWeight[MOM] * childProduct;
#endif
		} /* fresh likelihood calculation */
	    } /* one parent is the proband */

	} /* end of processing a complete multilocus parental pair */

    }	/* move on to next pair on this locus */

} /* end of loop_phases() */ 

/*
 * Get haplotype frequency for founders under LD analysis */
void
get_haplotype_freq (int locus, int parent, void *freqPtr,
		    ParentalPairSpace * pHaplo)
{
  int origLocus1, origLocus2; /* locus indices in the original locus list for the two loci in LD */
  double freq = 0;  /* variable to store the calculated frequency */
#ifndef NO_POLYNOMIAL
  Polynomial *freqPolynomial = NULL; 
  char vName[100];
#endif
  ParentalPair *pPair1;  /* parental pair for one locus */
  ParentalPair *pPair2; /* parental pair for the other locus */
  Locus *pLocus1; /* first locus */
  Locus *pLocus2; /* the other locus */
  int i, k, l;
  LDLoci *pLDLoci; /* structure contains LD parameter values */
  int alleleID1, alleleID2; /* allele IDs */
  AlleleSet *pAlleleSet1, *pAlleleSet2; /* allele sets */
  int allele1, allele2; /* */

  /* locus index in the original locus list for the first locus */
  origLocus1 = locusList->pLocusIndex[locus - 1];
  /* locus index in the original locus list for the second locus */
  origLocus2 = locusList->pLocusIndex[locus];
  pLocus1 = originalLocusList.ppLocusList[origLocus1];
  pLocus2 = originalLocusList.ppLocusList[origLocus2];
  /* find the parameter values for these two loci */
  pLDLoci = find_LD_loci (origLocus1, origLocus2);
  KASSERT (pLDLoci != NULL,
	   "Can't find LD parameter between loci %d,%d.\n",
	   origLocus1, origLocus2);
  /* now find the corresponding haplotype frequency : 2 haplotypes 
   * paternal haplotype & maternal haplotype */
  pPair1 =
    &pHaplo->ppParentalPair[locus - 1][pHaplo->pParentalPairInd[locus - 1]];
  pPair2 = &pHaplo->ppParentalPair[locus][pHaplo->pParentalPairInd[locus]];
  for (i = DAD; i <= MOM; i++)
    {
      /* allele ID in the first locus */
      alleleID1 = pPair1->pGenotype[parent]->allele[i];
      /* allele ID in the second locus */
      alleleID2 = pPair2->pGenotype[parent]->allele[i];
      pAlleleSet1 = pLocus1->ppAlleleSetList[alleleID1 - 1];
      pAlleleSet2 = pLocus2->ppAlleleSetList[alleleID2 - 1];
#ifndef NO_POLYNOMIAL
      if (modelOptions.polynomial == TRUE)
	{
	  freqPolynomial = constantExp (0);
	}
      else
	freq = 0;
#else
      freq = 0;
#endif
      for (k = 0; k < pAlleleSet1->numAllele; k++)
	{
	  for (l = 0; l < pAlleleSet2->numAllele; l++)
	    {
	      allele1 = pAlleleSet1->pAlleles[k];
	      allele2 = pAlleleSet2->pAlleles[l];
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  sprintf (vName, "ppHaploFreq[%d][%d]",
			   allele1 - 1, allele2 - 1);
		  freqPolynomial =
		    plusExp (2, 1.0, *freqPolynomial, 1.0,
			     variableExp (&pLDLoci->ppHaploFreq[allele1 - 1][allele2 - 1], 
					  NULL, 'D', vName),
			     1);
		}
	      else
		freq += pLDLoci->ppHaploFreq[allele1 - 1][allele2 - 1];
#else
	      freq += pLDLoci->ppHaploFreq[allele1 - 1][allele2 - 1];
#endif
	    }
	}

#ifndef NO_POLYNOMIAL
      if (modelOptions.polynomial == TRUE)
	{
	  *(Polynomial **)freqPtr = freqPolynomial;
	}
      else
	{
	  *(double *)freqPtr = freq;
	}
#else
      *(double *)freqValue = freq;
#endif
    }	/* end of loop of parents */
}

/* loop over a child's list of genotypes that are compatible with the parental pair
 * retrieve the transmission probability saved in the transmission matrix 
 * sum the likelihood for each genotype configuration
 */
int
loop_child_multi_locus_genotype (Person * pChild, 
				 Person * pProband,
				 ParentalPairSpace * pHaplo, 
				 int child,
				 int locus, 
				 int multiLocusIndex,
				 void *pSum, 
				 int xmissionIndex[2])
{
  int i;
  Genotype *pGeno;  /* this child's genotype at current locus */
  int genoIndex; /* index of the geno in the list */
  /* parental pair we are working on now */
  ParentalPair *pParentalPair =
    &pHaplo->ppParentalPair[locus][pHaplo->pParentalPairInd[locus]];
  int parent; /* parent - DAD or MOM */
  int origLocus = locusList->pLocusIndex[locus];
  double newProb =1;
#ifndef NO_POLYNOMIAL
  Polynomial *newProbPolynomial = NULL;
#endif
  int newChromosome[2];
  int numGenotype;
  int multiLocusIndex2;
  int newXmissionIndex[2];

  /* number of possible genotypes at this locus for this child */
  numGenotype = pChild->pSavedNumGenotype[origLocus];
  /* child's conditional likelihood offset for the multilocus genotype this function is building */
  multiLocusIndex2 = multiLocusIndex * numGenotype;
  /* build the index to xmission matrix for paternal inheritance and maternal inheritance */
  xmissionIndex[DAD] *= 3;
  xmissionIndex[MOM] *= 3;
  
  /* loop through all of this child's compatible genotypes at this locus */
  for (i = 0; i < pParentalPair->pChildGenoLen[child]; i++)
    {
      pGeno = pParentalPair->pppChildGenoList[child][i];
      /* record the index to the genotype list for this child */
      pHaplo->pChildGenoInd[locus] = i;
      KLOG (LOGLIKELIHOOD, LOGDEBUG,
	    "\t child %s locus %4d -> %4d|%-4d \n",
	    pChild->sID, locusList->pLocusIndex[locus], pGeno->allele[DAD],
	    pGeno->allele[MOM]);
      /* record this child's conditional likelihood index */
      multiLocusIndex = multiLocusIndex2 + pGeno->position;

      if (locus < locusList->numLocus)
	{
	  /* check the transmission probability */
	  for (parent = DAD; parent <= MOM; parent++)
	    {
	      newChromosome[parent] =
		pParentalPair->ppChildInheritance[parent][child][i];
	      /* xmissionIndex has already been multiplied by 3 before the loop */
	      newXmissionIndex[parent] =
		xmissionIndex[parent] + newChromosome[parent] - 1;
	    }			/* looping paternal and maternal chromosomes */
	  if (locus < locusList->numLocus - 1)
	    {
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
//                fprintf(stderr,"AAlocus=%d newPen=%f pSum=%f newProb=%f i=%d\n",
//                        locus,evaluateValue(newPenetrancePolynomial),
//                evaluateValue(*(Polynomial **)pSum),evaluateValue(newProbPolynomial),i);      
		  loop_child_multi_locus_genotype (pChild, pProband, pHaplo,
						   child, locus + 1,
						   multiLocusIndex,
						   pSum, 
						   newXmissionIndex);
//                fprintf(stderr,"BBlocus=%d newPen=%f pSum=%f newProb=%f\n",
//                        locus,evaluateValue(newPenetrancePolynomial),
//                evaluateValue(*(Polynomial **)pSum),evaluateValue(newProbPolynomial));                   
		}
	      else
		{
//                   fprintf(stderr,"AAlocus=%d newPen=%f, pSum=%f newProb=%f i=%d\n",
//                                   locus, newPenetrance, *((double *)pSum),newProb,i);
		  loop_child_multi_locus_genotype (pChild, pProband, pHaplo,
						   child, locus + 1,
						   multiLocusIndex,
						   pSum,
						   newXmissionIndex);
//                   fprintf(stderr,"BBlocus=%d newPen=%f, pSum=%f newProb=%f\n",
//                                   locus,newPenetrance, *((double *)pSum),newProb);
		}
#else
	      loop_child_multi_locus_genotype (pChild, pProband, pHaplo,
					       child, locus + 1,
					       multiLocusIndex,
					       pSum, 
					       newXmissionIndex);
#endif
	    }
	  else
	    {
	      /* get the transmission probability from the matrix */

#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  newProbPolynomial =
		    timesExp (2,
			      xmissionMatrix[newXmissionIndex[DAD]].
			      probPoly[DAD + 1], 1,
			      xmissionMatrix[newXmissionIndex[MOM]].
			      probPoly[MOM + 1], 1, 0);
//                fprintf(stderr,"newProb=%f newPenetrance=%f\n",
//                evaluateValue(newProbPolynomial),evaluateValue(newPenetrancePolynomial));
		}
	      else
		{
		  newProb =
		    xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1] *
		    xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1];
		  KLOG (LOGLIKELIHOOD, LOGDEBUG,
			"\t xmission prob: %f = %f * %f\n", newProb,
			xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1],
			xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1]);
//                 fprintf(stderr,"newProb=%f newPenetrance=%f\n",newProb,newPenetrance);
		}
#else
	      newProb = xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1] *
		xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1];
	      KLOG (LOGLIKELIHOOD, LOGDEBUG,
		    "\t xmission prob: %f = %f * %f\n",
		    newProb,
		    xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1],
		    xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1]);
#endif

	      /* we have completed one multilocus genotype for this child */
	      /* check whether we already have some information about this kid
	       * we should have if this kid is a connector to another nuclear
	       * family we have processed before */
#ifndef NO_POLYNOMIAL
	      if(modelOptions.polynomial == TRUE)
		{
		  if (pChild != pProband)
		    {
		      /* the child is not a proband */
		      if (pChild->touchedFlag == 1)
			{
			  /* some likelihood calculation has been calculated for this child */
			  *(Polynomial **) pSum = plusExp (2, 
							   1.0, 
							   *(Polynomial **) pSum, 
							   1.0, 
							   timesExp (2, 
								     newProbPolynomial, 
								     1, 
								     pChild->pLikelihood[multiLocusIndex].likelihoodPolynomial, 
								     1, 
								     0),	//end of timesExp
							   1);	//end of plusExp
			}
		      else if (locusList->traitLocusIndex >= 0)
			/* first time working on this child's current multilocus genotype 
			 * and we need to consider penetrance 
			 */
			{
			  genoIndex = pHaplo->pChildGenoInd[locusList->traitLocusIndex];
			  *(Polynomial **) pSum = plusExp (2, 
							   1.0, 
							   *(Polynomial **) pSum, 
							   1.0, 
							   timesExp (2, 
								     newProbPolynomial, 
								     1, 
								     pParentalPair->pppChildGenoList[child]
								     [genoIndex]->
								     penetrancePolynomial, 
								     1, 
								     0),	//end of timesExp
							   1);	//end of plusExp
			}
		      else
			{
			  /* no trait locus and new to this child */
			  *(Polynomial **) pSum = plusExp (2, 
							   1.0, 
							   *(Polynomial **) pSum, 
							   1.0, 
							   newProbPolynomial, 
							   1);
			}
		    }
		  else /* this child is not proband */
		    {
		      *(Polynomial **) pSum = plusExp (2, 
						       1.0, 
						       *(Polynomial **) pSum, 
						       1.0, 
						       newProbPolynomial, 
						       1);
		    }
		}
	      else /* PE is not turned on */
		{
		  if (pChild != pProband)
		    {
		      /* the child is not a proband */
		      if (pChild->touchedFlag == 1)
			{
			  /* some likelihood calculation has been done for this child */
			  *(double *) pSum += newProb *
			    pChild->pLikelihood[multiLocusIndex].likelihood;
			}
		      else if (locusList->traitLocusIndex >= 0)
			/* first time working on this child's current multilocus genotype 
			 * and we need to consider penetrance 
			 */
			{
			  genoIndex = pHaplo->pChildGenoInd[locusList->traitLocusIndex];
			  *(double *) pSum +=
			    newProb * pParentalPair->pppChildGenoList[child][genoIndex]->
			    penetrance;
			}
		      else
			{
			  *(double *) pSum += newProb;
			}
		    }
		  else /* this child is proband */
		    {
		      /* penetrance if applicable will be figured into later */
		      *(double *) pSum += newProb;
		    }
		}
#else /* PE is not compiled in */
	      if (pChild != pProband)
		{
		  /* the child is not a proband */
		  if (pChild->touchedFlag == 1)
		    {
		      /* some likelihood calculation has been done for this child */
		      *(double *) pSum += newProb *
			pChild->pLikelihood[multiLocusIndex].likelihood;
		    }
		  else if (locusList->traitLocusIndex >= 0)
		    /* first time working on this child's current multilocus genotype 
		     * and we need to consider penetrance 
		     */
		    {
		      genoIndex = pHaplo->pChildGenoInd[locusList->traitLocusIndex];
		      *(double *) pSum +=
			newProb * pParentalPair->pppChildGenoList[child][genoIndex]->
			penetrance;
		    }
		  else
		    {
		      *(double *) pSum += newProb;
		    }
		}
	      else /* this child is proband */
		{
		  /* penetrance if applicable will be figured into later */
		  *(double *) pSum += newProb;
		}
#endif
	      
	    }			/* end of processing one complete multilocus genotype */
	}
    }				/* end of looping the genotype list for this locus */
  return 0;
}


/* A recursive call to build transmission probability matrix 
 * pMatrix - pass in matrix pointer - This should have been pre-allocated
 * totalLoci - total number of loci
 * loc - current locus 
 * prob - 
 */

int
populate_xmission_matrix (XMission * pMatrix, int totalLoci,
			  void *prob[3], void *prob2[3],
			  void *hetProb[3],
			  int cellIndex,
			  int lastHetLoc, int prevPattern, int loc)
{
  int pattern;
#ifndef NO_POLYNOMIAL
  Polynomial *newProbPoly[3];
  Polynomial *newProbPoly2[3];
  Polynomial *newHetProbPoly[3];
#endif
  double newProb[3];
  double *newProbPtr[3] = { &newProb[0], &newProb[1], &newProb[2] };
  double newProb2[3];
  double *newProbPtr2[3] = { &newProb2[0], &newProb2[1], &newProb2[2] };
  double *newHetProbPtr[3] = { hetProb[0], hetProb[1], hetProb[2] };
  int newCellIndex;
  int newLastHetLoc;
  int i;
  char vName1[100];

  /* at each locus, the inheritance could be paternal only (1), maternal only (2), and
   * both (3) which indicates the parent is homozygous at that locus */
  for (pattern = 1; pattern <= 3; pattern++)
    {
      /* sex averaged or sex specific map */
      for (i = 0; i < 3; i++)
	{
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      newProbPoly[i] = (Polynomial *) prob[i];
	      newProbPoly2[i] = (Polynomial *) prob2[i];
	      newHetProbPoly[i] = (Polynomial *) hetProb[i];
	    }
	  else
	    {
	      newProb[i] = *((double *) prob[i]);
	      newProb2[i] = *((double *) prob2[i]);
	      newHetProbPtr[i] = hetProb[i];
	    }
#else
	  newProb[i] = *((double *) prob[i]);
	  newProb2[i] = *((double *) prob2[i]);
	  newHetProbPtr[i] = hetProb[i];
#endif
	}
      newCellIndex = cellIndex * 3 + pattern - 1;
      newLastHetLoc = lastHetLoc;
      if (pattern != 3)
	{
	  /* parent is not homozygous */
	  if (lastHetLoc != -1)
	    {
	      if (prevPattern != 3)
		{
		  /* previous locus for the parent is het and 
		     current locus pattern is either paternal or maternal */
		  if (prevPattern == pattern)
		    {
		      /* no recombination */
		      for (i = 0; i < 3; i++)
			{
#ifndef NO_POLYNOMIAL
			  if (modelOptions.polynomial == TRUE)
			    {
			      sprintf (vName1, "theta%d_%d", i, loc);
			      newProbPoly[i] =
				timesExp (2, newProbPoly[i], 1,
					  plusExp (2, 1.0, constantExp (1.0),
						   -1.0,
						   variableExp (&locusList->
								pPrevLocusDistance
								[i][loc],
								NULL, 'D',
								vName1), 0),
					  1, 0);
			    }
			  else
			    {
			      newProb[i] *=
				(1 - locusList->pPrevLocusDistance[i][loc]);
			    }
#else
			  newProb[i] *=
			    (1 - locusList->pPrevLocusDistance[i][loc]);
#endif
			}
		    }
		  else
		    {
		      /* recombination */
		      for (i = 0; i < 3; i++)
#ifndef NO_POLYNOMIAL
			if (modelOptions.polynomial == TRUE)
			  {
			    sprintf (vName1, "theta%d_%d", i, loc);
			    newProbPoly[i] = timesExp (2, newProbPoly[i], 1,
						       variableExp
						       (&locusList->
							pPrevLocusDistance[i]
							[loc], NULL, 'D',
							vName1), 1, 0);

			  }
			else
			  {
			    newProb[i] *=
			      locusList->pPrevLocusDistance[i][loc];
			  }
#else
			newProb[i] *= locusList->pPrevLocusDistance[i][loc];
#endif
		    }
		}
	      else
		{
		  /* previous locus at parent is homo and current locus is het */
		  for (i = 0; i < 3; i++)
		    {
		      if (pattern == 1)
			{
			  /* paternal inheritance for this locus
			     either no recombination from previous paternal strand 
			     or recombination from previous maternal strand */
#ifndef NO_POLYNOMIAL
			  if (modelOptions.polynomial == TRUE)
			    {
			      sprintf (vName1, "theta%d_%d", i, loc);
			      newProbPoly[i] = plusExp (2,
							1.0, 
							timesExp (2,
								  (Polynomial *) prob[i], 
								  1,
								  plusExp(2, 
									  1.0,
									  constantExp(1.0),
									  -1.0,
									  variableExp(
										      &locusList->
										      pPrevLocusDistance[i][loc],
										      NULL,
										      'D',
										      vName1),
									  0), 
								  1,
								  0),
							1.0, 
							timesExp (2,
								  (Polynomial *)prob2[i], 
								  1,
								  variableExp(
									      &locusList->
									      pPrevLocusDistance[i][loc],
									      NULL,
									      'D',
									      vName1),
								  1, 
								  0),
							0);
			    }
			  else
			    newProb[i] = *((double *) prob[i]) *
			      (1 - locusList->pPrevLocusDistance[i][loc]) +
			      *((double *) prob2[i]) *
			      locusList->pPrevLocusDistance[i][loc];
#else
			  newProb[i] = *((double *) prob[i]) *
			    (1 - locusList->pPrevLocusDistance[i][loc]) +
			    *((double *) prob2[i]) *
			    locusList->pPrevLocusDistance[i][loc];
#endif
			}
		      else
			{
			  /* has to be maternal */
#ifndef NO_POLYNOMIAL
			  if (modelOptions.polynomial == TRUE)
			    {
			      sprintf (vName1, "theta%d_%d", i, loc);
			      newProbPoly[i] = plusExp (2,
							1.0, 
							timesExp (2,
								  (Polynomial *)prob2[i], 
								  1,
								  plusExp(2,
									  1.0,
									  constantExp(1.0),
									  -1.0,
									  variableExp(
										      &locusList->
										      pPrevLocusDistance[i][loc],
										      NULL,
										      'D',
										      vName1),
									  0), 
								  1,
								  0),
							1.0, 
							timesExp (2,
								  (Polynomial *)prob[i], 
								  1,
								  variableExp(
									      &locusList->
									      pPrevLocusDistance[i][loc],
									      NULL,
									      'D',
									      vName1),
								  1, 
								  0),
							0);

			    }
			  else
			    newProb[i] = *((double *) prob2[i]) *
			      (1 - locusList->pPrevLocusDistance[i][loc]) +
			      *((double *) prob[i]) *
			      locusList->pPrevLocusDistance[i][loc];

#else
			  newProb[i] = *((double *) prob2[i]) *
			    (1 - locusList->pPrevLocusDistance[i][loc]) +
			    *((double *) prob[i]) *
			    locusList->pPrevLocusDistance[i][loc];
#endif
			}
		    }

		}		/* end of prevPattern is homo and current pattern is het */
	    }			/* end of prevHetLoc != -1 */
	  else
	    {
	      /* we don't have any het locus yet, this locus is the first het */
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  for (i = 0; i < 3; i++)
		    newProbPoly[i] = constantExp (0.5);
		}
	      else
		{
		  for (i = 0; i < 3; i++)
		    newProb[i] = 0.5;
		}
#else
	      for (i = 0; i < 3; i++)
		newProb[i] = 0.5;
#endif
	    }
	  newLastHetLoc = loc;


#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      for (i = 0; i < 3; i++)
		newHetProbPoly[i] = newProbPoly[i];
	    }
	  else
	    {
	      for (i = 0; i < 3; i++)
		newHetProbPtr[i] = newProbPtr[i];
	    }
#else
	  for (i = 0; i < 3; i++)
	    newHetProbPtr[i] = newProbPtr[i];
#endif


	}			/* end of current pattern is not homo */
      else
	{
	  /* current pattern is homo */
	  if (lastHetLoc == -1)
	    /* nothing needs to be done for this locus */
	    ;
	  else
	    {
	      if (loc == totalLoci - 1)
		{
		  /* this is the last locus and it's homo, take the previous het locus */
		  for (i = 0; i < 3; i++)
		    {
#ifndef NO_POLYNOMIAL
		      if (modelOptions.polynomial == TRUE)
			{
			  newProbPoly[i] = (Polynomial *) hetProb[i];
			}
		      else
			newProb[i] = *(double *) hetProb[i];
#else
		      newProb[i] = *(double *) hetProb[i];
#endif
		    }
		}
	      else
		{
		  if (prevPattern == 3)
		    {
		      /* previous locus pattern is homo */
		      for (i = 0; i < 3; i++)
			{

#ifndef NO_POLYNOMIAL
			  if (modelOptions.polynomial == TRUE)
			    {
			      sprintf (vName1, "theta%d_%d", i, loc);
			      newProbPoly[i] = plusExp (2,
							1.0, 
							timesExp (2,
								  (Polynomial *)prob[i], 
								  1,
								  plusExp(
									  2,
									  1.0,
									  constantExp(1.0),
									  -1.0,
									  variableExp(&locusList->
										      pPrevLocusDistance
										      [i]
										      [loc],
										      NULL,
										      'D',
										      vName1),
									  0), 
								  1,
								  0),
							1.0, 
							timesExp (2,
								  (Polynomial *)prob2[i], 
								  1,
								  variableExp(
									      &locusList->
									      pPrevLocusDistance
									      [i]
									      [loc],
									      NULL,
									      'D',
									      vName1),
								  1, 
								  0),
							0);
			      newProbPoly2[i] =
				plusExp (2, 
					 1.0,
					 timesExp (2, 
						   (Polynomial *) prob2[i],
						   1, 
						   plusExp (2, 
							    1.0,
							    constantExp(1.0), 
							    -1.0,
							    variableExp(&locusList->
									pPrevLocusDistance[i][loc],
									NULL, 
									'D',
									vName1), 
							    0),
						   1, 
						   0), 
					 1.0, 
					 timesExp (2,
						   (Polynomial *)prob[i],
						   1,
						   variableExp(&locusList->
							       pPrevLocusDistance[i][loc],
							       NULL,
							       'D',
							       vName1),
						   1,
						   0),
					 0);
			      
			    }
			  else
			    {
			      newProb[i] = *(double *) prob[i] *
				(1 - locusList->pPrevLocusDistance[i][loc]) +
				*((double *) prob2[i]) *
				locusList->pPrevLocusDistance[i][loc];

			      newProb2[i] = *(double *) prob2[i] *
				(1 - locusList->pPrevLocusDistance[i][loc]) +
				*((double *) prob[i]) *
				locusList->pPrevLocusDistance[i][loc];
			    }
#else
			  newProb[i] = *(double *) prob[i] *
			    (1 - locusList->pPrevLocusDistance[i][loc]) +
			    *((double *) prob2[i]) *
			    locusList->pPrevLocusDistance[i][loc];

			  newProb2[i] = *(double *) prob2[i] *
			    (1 - locusList->pPrevLocusDistance[i][loc]) +
			    *((double *) prob[i]) *
			    locusList->pPrevLocusDistance[i][loc];
#endif
			}
		    }
		  else
		    {
		      for (i = 0; i < 3; i++)
			{
			  if (prevPattern == 1)
			    {
#ifndef NO_POLYNOMIAL
			      if (modelOptions.polynomial == TRUE)
				{
				  sprintf (vName1, "theta%d_%d", i, loc);
				  newProbPoly[i] =
				    timesExp (2, (Polynomial *) prob[i], 1,
					      plusExp (2, 1.0,
						       constantExp (1.0),
						       -1.0,
						       variableExp
						       (&locusList->
							pPrevLocusDistance[i]
							[loc], NULL, 'D',
							vName1), 0), 1, 0);
				  newProbPoly2[i] =
				    timesExp (2, (Polynomial *) prob[i], 1,
					      variableExp (&locusList->
							   pPrevLocusDistance
							   [i][loc], NULL,
							   'D', vName1), 1,
					      0);
				}
			      else
				{
				  newProb[i] = *(double *) prob[i] *
				    (1 -
				     locusList->pPrevLocusDistance[i][loc]);
				  newProb2[i] =
				    *(double *) prob[i] *
				    locusList->pPrevLocusDistance[i][loc];
				}
#else
			      newProb[i] = *(double *) prob[i] *
				(1 - locusList->pPrevLocusDistance[i][loc]);

			      newProb2[i] = *(double *) prob[i] *
				locusList->pPrevLocusDistance[i][loc];
#endif
			    }
			  else
			    {
#ifndef NO_POLYNOMIAL
			      if (modelOptions.polynomial == TRUE)
				{
				  sprintf (vName1, "theta%d_%d", i, loc);
				  newProbPoly2[i] =
				    timesExp (2, (Polynomial *) prob[i], 1,
					      plusExp (2, 1.0,
						       constantExp (1.0),
						       -1.0,
						       variableExp
						       (&locusList->
							pPrevLocusDistance[i]
							[loc], NULL, 'D',
							vName1), 0), 1, 0);
				  newProbPoly[i] =
				    timesExp (2, (Polynomial *) prob[i], 1,
					      variableExp (&locusList->
							   pPrevLocusDistance
							   [i][loc], NULL,
							   'D', vName1), 1,
					      0);
				}
			      else
				{
				  newProb2[i] = *(double *) prob[i] *
				    (1 -
				     locusList->pPrevLocusDistance[i][loc]);
				  newProb[i] =
				    *(double *) prob[i] *
				    locusList->pPrevLocusDistance[i][loc];
				}
#else
			      newProb2[i] = *(double *) prob[i] *
				(1 - locusList->pPrevLocusDistance[i][loc]);

			      newProb[i] = *(double *) prob[i] *
				locusList->pPrevLocusDistance[i][loc];
#endif
			    }

			}
		    }
		}
	    }
	}

      if (loc == totalLoci - 1)
	{
	  /* we have a complete set of multilocus inheritance pattern */

	  for (i = 0; i < 3; i++)
	    {
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  pMatrix[newCellIndex].probPoly[i] = newProbPoly[i];
		}
	      else
		pMatrix[newCellIndex].prob[i] = newProb[i];
#else
	      pMatrix[newCellIndex].prob[i] = newProb[i];
#endif
	    }

	}
      else
	{
	  /* move on to next locus */
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      populate_xmission_matrix (pMatrix, totalLoci,
					(void *) newProbPoly,
					(void *) newProbPoly2,
					(void *) newHetProbPoly, newCellIndex,
					newLastHetLoc, pattern, loc + 1);
	    }
	  else
	    populate_xmission_matrix (pMatrix, totalLoci,
				      (void *) newProbPtr,
				      (void *) newProbPtr2,
				      (void *) newHetProbPtr, newCellIndex,
				      newLastHetLoc, pattern, loc + 1);
#else
	  populate_xmission_matrix (pMatrix, totalLoci,
				    newProbPtr, (void *) newProbPtr2,
				    (void *) newHetProbPtr,
				    newCellIndex,
				    newLastHetLoc, pattern, loc + 1);
#endif
	}
    }
  return 0;
}

int
build_xmission_matrix (XMission ** ppMatrix, int totalLoci)
{
  int size;
  //  int i;

  *ppMatrix = NULL;
  size = pow (3, totalLoci);
  /* minimal two loci */
  if (size < 9)
    size = 9;
  *ppMatrix = (XMission *) calloc (size, sizeof (XMission));
  if (*ppMatrix == NULL)
    /* memory allocation failed */
    return -1;

  return 0;
}

void
print_xmission_matrix (XMission * pMatrix, int totalLoci, int loc,
		       int cellIndex, char *pID)
{
  int pattern;
  int newCellIndex;
  int i;

  for (pattern = 1; pattern <= 3; pattern++)
    {
      newCellIndex = cellIndex * 3 + pattern - 1;
      if (pattern == 1)
	{
	  pID[loc] = 'P';
	}
      else if (pattern == 2)
	{
	  pID[loc] = 'M';
	}
      else
	{
	  pID[loc] = 'B';
	}
      if (loc != totalLoci - 1)
	{
	  /* not complete multi-locus haplotype yet */
	  print_xmission_matrix (pMatrix, totalLoci, loc + 1, newCellIndex,
				 pID);
	}
      else
	{
	  /* print the xmission probability out */
	  for (i = 0; i <= loc; i++)
	    {
	      fprintf (stderr, "%c", pID[i]);
	    }
	  fprintf (stderr, ":%f\n", pMatrix[newCellIndex].prob[0]);
	}
    }
}

/* allocate storage for keeping track of het locus in nuclear families */
void allocate_nucfam_het(PedigreeSet *pPedigreeList, int numLocus)
{
  int ped;
  Pedigree *pPedigree;
  int fam;
  NuclearFamily *pNucFam; 

  for (ped = 0; ped < pPedigreeList->numPedigree; ped++)
    {
      pPedigree = pPedigreeList->ppPedigreeSet[ped];
      for (fam = 0; fam < pPedigree->numNuclearFamily; fam++)
	{
	  pNucFam = pPedigree->ppNuclearFamilyList[fam];
	  if(pNucFam->hetFlag[DAD] == NULL)
	    {
	      pNucFam->hetFlag[DAD] = (int *)calloc(sizeof(int), numLocus);
	      pNucFam->hetFlag[MOM] = (int *)calloc(sizeof(int), numLocus);
	      pNucFam->tmpNumHet[DAD] = (int *) calloc(sizeof(int), numLocus);
	      pNucFam->tmpNumHet[MOM] = (int *) calloc(sizeof(int), numLocus);
	    }
	}
    }

}
