/* using the parental pair algorithm to go through all possible 
 * parental pairs and calculate the likelihood of each parental pair 
 * nested looping is for the multi-locus */
int
loop_parental_pair (NuclearFamily * pNucFam,
		    Person * pProband,
		    int locus,
		    ParentalPairSpace * pHaplo,
		    int multiLocusIndex[2],
		    void *dWeight[2], void *dPenetrance[2], void *pParentSum)
{
  double sum;
  double prob;
  int chromosome[2] = { DAD, DAD };
  Locus *pLocus =
    originalLocusList.ppLocusList[locusList->pLocusIndex[locus]];
  Locus *pLocusTemp;
  ParentalPair *pPair;
  ParentalPair *pTempPair;
  int child;
  int k, l;
  int origLocus;
  int origLocus1, origLocus2;
  LDLoci *pLDLoci;
  int allele1, allele2;
  int alleleID1, alleleID2;
  AlleleSet *pAlleleSet1, *pAlleleSet2;
  int i, j;
  double freq = 0;
  int multiLocusIndex2[2];
  Person *pParent[2];
  int numGenotype[2];
  int xmissionIndex[2];
  double newWeight[2];		/* genotype weight */
  double newPenetrance[2];
  double childProduct = 1;
  double childPenetrance = 1;
  int numPair;
  int breakFlag = 0;

#ifndef NO_POLYNOMIAL
  Polynomial *freqPolynomial = NULL;
  Polynomial *sumPolynomial = NULL;
  Polynomial *probPolynomial = NULL;
  Polynomial *newWeightPolynomial[2] = { NULL, NULL };
  Polynomial *newPenetrancePolynomial[2] = { NULL, NULL };
  Polynomial *childProductPolynomial = NULL;
  Polynomial *childPenetrancePolynomial = NULL;
  if (modelOptions.polynomial == TRUE)
    {
      childPenetrancePolynomial = constantExp (1);
    }
#endif

  origLocus = locusList->pLocusIndex[locus];
  for (i = DAD; i <= MOM; i++)
    {
      pParent[i] = pNucFam->pParents[i];
      /* find the max number of possible genotypes for this parent */
      numGenotype[i] = pNucFam->pParents[i]->pSavedNumGenotype[origLocus];
      multiLocusIndex2[i] = multiLocusIndex[i] * numGenotype[i];
    }
  //  pPair = pNucFam->ppParentalPair[locus];
  numPair = -1;
  while ((numPair += 1) < pHaplo->pNumParentalPair[locus])
    {
      //      pHaplo->ppParentalPairs[locus] = pPair;
      pPair = &pHaplo->ppParentalPair[locus][numPair];
      pHaplo->pParentalPairInd[locus] = numPair;
      for (i = DAD; i <= MOM; i++)
	{
	  multiLocusIndex[i] =
	    multiLocusIndex2[i] + pPair->pGenotype[i]->position;
	  if (pLocusType == = LOCUS_TYPE_TRAIT)
	    {
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{

		  newPenetrancePolynomial[i] =
		    timesExp (2, (Polynomial *) dPenetrance[i], 1,
			      pPair->pGenotype[i]->penetrancePolynomial, 1,
			      0);

		}
	      else
		{
		  newPenetrance[i] = *((double *) dPenetrance + i) *
		    pPair->pGenotype[i]->penetrance;
		}
#else
	      newPenetrance[i] = *((double *) dPenetrance + i) *
		pPair->pGenotype[i]->penetrance;
#endif
	    }
	  else
	    {

#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  newPenetrancePolynomial[i] = (Polynomial *) dPenetrance[i];
		}
	      else
		{
		  newPenetrance[i] = *((double *) dPenetrance + i);
		}
#else
	      newPenetrance[i] = *((double *) dPenetrance + i);
#endif
	    }

	  if (pParent[i] == pProband)
	    {
	      /* we are conditionaling on proband, so it's 1 */
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  newWeightPolynomial[i] = constantExp (1);
		}
	      else
		{
		  newWeight[i] = 1;
		}
#else
	      newWeight[i] = 1;
#endif
	    }
	  else
	    {
	      /* we don't have weight information of this individual yet */
	      if (modelOptions.equilibrium == LINKAGE_EQUILIBRIUM)
		{
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      newWeightPolynomial[i] =
			timesExp (2, (Polynomial *) dWeight[i], 1,
				  pPair->pGenotype[i]->weightPolynomial, 1,
				  0);
		    }
		  else
		    {
		      newWeight[i] =
			*((double *) dWeight +
			  i) * pPair->pGenotype[i]->weight;
		    }
#else
		  newWeight[i] =
		    *((double *) dWeight + i) * pPair->pGenotype[i]->weight;
#endif
		}
	      else
		{		/* Linkage Disequilibrium */
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      newWeightPolynomial[i] = (Polynomial *) dWeight[i];
		    }
		  else
		    {
		      newWeight[i] = *((double *) dWeight + i);
		    }
#else
		  newWeight[i] = *((double *) dWeight + i);
#endif
		  /* instead of using genotype weight at each locus
		   * we need to use haplotype frequencies */
		  /* see whether current locus is in LD with previous locus */
		  if (locus > 0)
		    {
		      origLocus1 = locusList->pLocusIndex[locus - 1];
		      origLocus2 = locusList->pLocusIndex[locus];
		      pLocusTemp = originalLocusList.ppLocusList[origLocus1];
		      /* find the parameter values for these two loci */
		      pLDLoci = find_LD_loci (origLocus1, origLocus2);
		      KASSERT (pLDLoci != NULL,
			       "Can't find LD parameter between loci %d,%d.\n",
			       origLocus1, origLocus2);
		      /* now find the corresponding haplotype frequency : 2 haplotypes 
		       * paternal haplotype & maternal haplotype */
		      pTempPair =
			&pHaplo->ppParentalPair[locus -
						1][pHaplo->
						   pParentalPairInd[locus -
								    1]];
		      for (j = DAD; j <= MOM; j++)
			{
			  alleleID2 = pPair->pGenotype[i]->allele[j];
			  alleleID1 = pTempPair->pGenotype[i]->allele[j];
			  pAlleleSet1 =
			    pLocusTemp->ppAlleleSetList[alleleID1 - 1];
			  pAlleleSet2 =
			    pLocus->ppAlleleSetList[alleleID2 - 1];
#ifndef NO_POLYNOMIAL
			  if (modelOptions.polynomial == TRUE)
			    {
			      freqPolynomial = constantExp (0);
			    }
			  else
			    freq = 0;
#else
			  freq = 0;
#endif
			  for (k = 0; k < pAlleleSet1->numAllele; k++)
			    {
			      for (l = 0; l < pAlleleSet2->numAllele; l++)
				{
				  allele1 = pAlleleSet1->pAlleles[k];
				  allele2 = pAlleleSet2->pAlleles[l];
#ifndef NO_POLYNOMIAL
				  if (modelOptions.polynomial == TRUE)
				    {
				      char vName[100];
				      sprintf (vName, "ppHaploFreq[%d][%d]",
					       allele1 - 1, allele2 - 1);
				      freqPolynomial =
					plusExp (2, 1.0, freqPolynomial, 1.0,
						 variableExp (&pLDLoci->
							      ppHaploFreq
							      [allele1 -
							       1][allele2 -
								  1], NULL,
							      'D', vName), 1);
				    }
				  else
				    freq +=
				      pLDLoci->ppHaploFreq[allele1 -
							   1][allele2 - 1];
#else
				  freq +=
				    pLDLoci->ppHaploFreq[allele1 -
							 1][allele2 - 1];
#endif
				}
			    }
#ifndef NO_POLYNOMIAL
			  if (modelOptions.polynomial == TRUE)
			    {
			      newWeightPolynomial[i] =
				timesExp (2, newWeightPolynomial[i], 1,
					  freqPolynomial, 1, 0);
			    }
			  else
			    {
			      newWeight[i] *= freq;
			    }
#else
			  newWeight[i] *= freq;
#endif
			}	/* end of looping paternal and maternal haplotypes */
		    }		/* if locus > 0 for LD case */

		}		/*  LD case */
	    }			/* not a proband */
	}			/* looping dad and mom genotypes */


      if (locus < locusList->numLocus - 1)
	{
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {

	      loop_parental_pair (pNucFam, pProband, locus + 1, pHaplo,
				  multiLocusIndex,
				  (void *) newWeightPolynomial,
				  (void *) newPenetrancePolynomial,
				  pParentSum);
	    }
	  else
	    {
	      loop_parental_pair (pNucFam, pProband, locus + 1, pHaplo,
				  multiLocusIndex,
				  (void *) newWeight, (void *) newPenetrance,
				  pParentSum);
	    }
#else
	  loop_parental_pair (pNucFam, pProband, locus + 1, pHaplo,
			      multiLocusIndex,
			      (void *) newWeight, (void *) newPenetrance,
			      pParentSum);
#endif
	}
      else
	{
	  /* check to see whether we already have likelihood calculated
	   * for this individual. If this individual is  a connector to
	   * another nuclear family, then we should have already got the
	   * likelihood stored for this person */

#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      pHaplo->likelihoodPolynomial = constantExp (1);
	    }
	  else
	    {
	      pHaplo->likelihood = 1;
	    }
#else
	  pHaplo->likelihood = 1;
#endif

	  breakFlag = 0;
	  for (i = DAD; i <= MOM; i++)
	    {
	      /* we will update proband later */
	      if (pParent[i] != pProband
		  && pParent[i]->pLikelihood[multiLocusIndex[i]].
		  touchedFlag != TRUE)
		{
		  /* stored the weight */
		  pParent[i]->pLikelihood[multiLocusIndex[i]].touchedFlag =
		    TRUE;
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      pParent[i]->pLikelihood[multiLocusIndex[i]].
			likelihoodPolynomial = newPenetrancePolynomial[i];
		    }
		  else
		    {
		      pParent[i]->pLikelihood[multiLocusIndex[i]].likelihood =
			newPenetrance[i];
		    }
#else
		  pParent[i]->pLikelihood[multiLocusIndex[i]].likelihood =
		    newPenetrance[i];
#endif
		}		/* getting the weight for this individual */

	      if (pParent[i] != pProband)
		{
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      pHaplo->likelihoodPolynomial =
			timesExp (2,
				  pHaplo->likelihoodPolynomial,
				  1,
				  pParent[i]->pLikelihood[multiLocusIndex[i]].
				  likelihoodPolynomial, 1, 1);
		    }
		  else
		    {
		      pHaplo->likelihood *=
			pParent[i]->pLikelihood[multiLocusIndex[i]].
			likelihood;
		      if (newPenetrance[i] == 0)
			{
			  breakFlag = 1;
			}
		    }
#else
		  pHaplo->likelihood *=
		    pParent[i]->pLikelihood[multiLocusIndex[i]].likelihood;
		  if (newPenetrance[i] == 0)
		    {
		      breakFlag = 1;
		    }
#endif
		}
	      else
		{
		}
	      if (pParent[i]->pParents[DAD] == NULL && pParent[i] != pProband)
		{
#ifndef NO_POLYNOMIAL
		  if (modelOptions.polynomial == TRUE)
		    {
		      pHaplo->likelihoodPolynomial =
			timesExp (2, pHaplo->likelihoodPolynomial, 1,
				  newWeightPolynomial[i], 1, 1);
		    }
		  else
		    {
		      pHaplo->likelihood *= newWeight[i];
		    }
#else
		  pHaplo->likelihood *= newWeight[i];
#endif
		}
	    }			/* update for each parent */

	  if (breakFlag == 1)
	    continue;
	  /* we got a complete multi-locus haplotype for the parents 
	   * now we need to loop over children for multi-locus */
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      childProductPolynomial = constantExp (1);
	    }
	  else
	    childProduct = 1;
#else
	  childProduct = 1;
#endif

	  for (child = 0; child < pNucFam->numChildren; child++)
	    {
	      xmissionIndex[DAD] = 0;
	      xmissionIndex[MOM] = 0;
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  sumPolynomial = constantExp (0);
		  probPolynomial = constantExp (1);
		  childPenetrancePolynomial = constantExp (1);
		  loop_child_multi_locus_genotype (pNucFam->
						   ppChildrenList[child],
						   pProband, pHaplo, child, 0,
						   0,
						   childPenetrancePolynomial,
						   &sumPolynomial,
						   probPolynomial,
						   xmissionIndex, chromosome);
		  childProductPolynomial =
		    timesExp (2, childProductPolynomial, 1, sumPolynomial, 1,
			      1);

//          fprintf(stderr,"Child No. %d\n",child);
//          expPrinting(sumPolynomial);
//          fprintf(stderr,"\n  value=%f\n",evaluateValue(sumPolynomial));

		}
	      else
		{
		  sum = 0;
		  prob = 1;
		  childPenetrance = 1;
		  /* get transmission probability */
		  loop_child_multi_locus_genotype (pNucFam->
						   ppChildrenList[child],
						   pProband, pHaplo, child, 0,
						   0, &childPenetrance, &sum,
						   &prob,
						   xmissionIndex, chromosome);

		  childProduct *= sum;
//          fprintf(stderr,"Child No. %d\n",child);
//          fprintf(stderr,"likelihood=%f\n",sum);

		}
#else
	      sum = 0;
	      prob = 1;
	      childPenetrance = 1;
	      /* get transmission probability */
	      loop_child_multi_locus_genotype (pNucFam->ppChildrenList[child],
					       pProband, pHaplo, child, 0, 0,
					       &childPenetrance,
					       &sum, &prob,
					       xmissionIndex, chromosome);

	      childProduct *= sum;
#endif
	    }
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {

	      pHaplo->likelihoodPolynomial =
		timesExp (2, pHaplo->likelihoodPolynomial, 1,
			  childProductPolynomial, 1, 1);
	      *(Polynomial **) pParentSum =
		plusExp (2, 1.0, *(Polynomial **) pParentSum, 1.0,
			 pHaplo->likelihoodPolynomial, 1);
	    }
	  else
	    {
	      pHaplo->likelihood *= childProduct;
	      *(double *) pParentSum += pHaplo->likelihood;
	    }
#else
	  pHaplo->likelihood *= childProduct;
	  *(double *) pParentSum += pHaplo->likelihood;
#endif
#if 0
	  memcpy (&pNucFam->pHaplotypePairs[pNucFam->numHaplotypePairs],
		  pHaplo, sizeof (HaplotypePair));
	  pNucFam->numHaplotypePairs++;
#endif
	  //haploProb = get_haplo_probability(pHaplo);
	  for (k = 0; k < locusList->numLocus; k++)
	    {
	      pTempPair =
		&pHaplo->ppParentalPair[k][pHaplo->pParentalPairInd[k]];
	      KLOG (LOGPARENTALPAIR, LOGDEBUG,
		    "\t %4d-> %4d|%-4d \t %4d|%-4d\n",
		    locusList->pLocusIndex[k],
		    pTempPair->pGenotype[DAD]->allele[DAD],
		    pTempPair->pGenotype[DAD]->allele[MOM],
		    pTempPair->pGenotype[MOM]->allele[DAD],
		    pTempPair->pGenotype[MOM]->allele[MOM]);
	    }
	  KLOG (LOGPARENTALPAIR, LOGDEBUG, "\n");

#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
//      expPrinting(pHaplo->likelihoodPolynomial);
//      KLOG (LOGPARENTALPAIR, LOGDEBUG, "\t Likelihood = %e\n",
//              evaluateValue (pHaplo->likelihoodPolynomial));
	    }
	  else
	    {
	      KLOG (LOGPARENTALPAIR, LOGDEBUG, "\t Likelihood = %e\n",
		    pHaplo->likelihood);
	    }
#else
	  KLOG (LOGPARENTALPAIR, LOGDEBUG, "\t Likelihood = %e\n",
		pHaplo->likelihood);
#endif
	}			/* end of processing one parental pair */
      //      numPair++; /* move to next parental pair */
    }

  return 0;
}

int
loop_child_multi_locus_genotype (Person * pChild, Person * pProband,
				 ParentalPairSpace * pHaplo, int child,
				 int locus, int multiLocusIndex,
				 void *pPenetrance,
				 void *pSum, void *pProb,
				 int xmissionIndex[2], int chromosome[2])
{
  int i;
  Genotype *pGeno;
  ParentalPair *pParentalPair =
    &pHaplo->ppParentalPair[locus][pHaplo->pParentalPairInd[locus]];
  int parent;
  //  int alleleSetLen = originalLocusList.alleleSetLen;
  int origLocus = locusList->pLocusIndex[locus];
  Locus *pLocus =
    originalLocusList.ppLocusList[locusList->pLocusIndex[locus]];

  double newProb;

#ifndef NO_POLYNOMIAL
  Polynomial *newProbPolynomial = NULL;
#endif

  int newChromosome[2];
  int newChromosome2[2];
  int numGenotype;
  double newPenetrance;
#ifndef NO_POLYNOMIAL
  Polynomial *newPenetrancePolynomial = NULL;
#endif
  int multiLocusIndex2;
  int newXmissionIndex[2];

  numGenotype = pChild->pSavedNumGenotype[origLocus];
  multiLocusIndex2 = multiLocusIndex * numGenotype;
  xmissionIndex[0] *= 3;
  xmissionIndex[1] *= 3;
  for (i = 0; i < pParentalPair->pChildGenoLen[child]; i++)
    {
      pGeno = pParentalPair->pppChildGenoList[child][i];
      KLOG (LOGLIKELIHOOD, LOGDEBUG,
	    "\t child %s locus %4d -> %4d|%-4d \n",
	    pChild->sID, locusList->pLocusIndex[locus], pGeno->allele[DAD],
	    pGeno->allele[MOM]);
      multiLocusIndex = multiLocusIndex2 + pGeno->position;
      newChromosome2[DAD] = chromosome[DAD];
      newChromosome2[MOM] = chromosome[MOM];
#ifndef NO_POLYNOMIAL
      if (modelOptions.polynomial == TRUE)
	{
	  newProbPolynomial = (Polynomial *) pProb;

	}
      else
	{
	  newProb = *(double *) pProb;

	}
#else
      newProb = *(double *) pProb;
#endif
      if (locus < locusList->numLocus)
	{
	  /* check the transmission probability */
	  for (parent = DAD; parent <= MOM; parent++)
	    {
	      newChromosome[parent] =
		pParentalPair->ppChildInheritance[parent][child][i];
	      /* xmissionIndex has already been multiplied by 3 before the loop */
	      newXmissionIndex[parent] =
		xmissionIndex[parent] + newChromosome[parent] - 1;
	    }			/* looping paternal and maternal chromsome */
	  if (locus < locusList->numLocus - 1)
	    {
#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
//                  fprintf(stderr,"AAlocus=%d newPen=%f pSum=%f newProb=%f i=%d\n",
//                                  locus,evaluateValue(newPenetrancePolynomial),
//                                evaluateValue(*(Polynomial **)pSum),evaluateValue(newProbPolynomial),i);      
		  loop_child_multi_locus_genotype (pChild, pProband, pHaplo,
						   child, locus + 1,
						   multiLocusIndex,
						   newPenetrancePolynomial,
						   pSum, newProbPolynomial,
						   newXmissionIndex,
						   newChromosome2);
//                   fprintf(stderr,"BBlocus=%d newPen=%f pSum=%f newProb=%f\n",
//                                locus,evaluateValue(newPenetrancePolynomial),
//                                evaluateValue(*(Polynomial **)pSum),evaluateValue(newProbPolynomial));                   
		}
	      else
		{
//                   fprintf(stderr,"AAlocus=%d newPen=%f, pSum=%f newProb=%f i=%d\n",
//                                   locus, newPenetrance, *((double *)pSum),newProb,i);
		  loop_child_multi_locus_genotype (pChild, pProband, pHaplo,
						   child, locus + 1,
						   multiLocusIndex,
						   &newPenetrance, pSum,
						   &newProb,
						   newXmissionIndex,
						   newChromosome2);
//                   fprintf(stderr,"BBlocus=%d newPen=%f, pSum=%f newProb=%f\n",
//                                   locus,newPenetrance, *((double *)pSum),newProb);
		}
#else
	      loop_child_multi_locus_genotype (pChild, pProband, pHaplo,
					       child, locus + 1,
					       multiLocusIndex,
					       &newPenetrance, pSum, &newProb,
					       newXmissionIndex,
					       newChromosome2);
#endif
	    }
	  else
	    {
	      /* get the transmission probability from the matrix */

#ifndef NO_POLYNOMIAL
	      if (modelOptions.polynomial == TRUE)
		{
		  newProbPolynomial =
		    timesExp (2,
			      xmissionMatrix[newXmissionIndex[DAD]].
			      probPoly[DAD + 1], 1,
			      xmissionMatrix[newXmissionIndex[MOM]].
			      probPoly[MOM + 1], 1, 0);
//                 fprintf(stderr,"newProb=%f newPenetrance=%f\n",
//                               evaluateValue(newProbPolynomial),evaluateValue(newPenetrancePolynomial));
		}
	      else
		{
		  newProb =
		    xmissionMatrix[newXmissionIndex[DAD]].prob[DAD +
							       1] *
		    xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1];
		  KLOG (LOGLIKELIHOOD, LOGDEBUG,
			"\t xmission prob: %f = %f * %f\n", newProb,
			xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1],
			xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1]);
//                 fprintf(stderr,"newProb=%f newPenetrance=%f\n",newProb,newPenetrance);
		}
#else
	      newProb = xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1] *
		xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1];
	      KLOG (LOGLIKELIHOOD, LOGDEBUG,
		    "\t xmission prob: %f = %f * %f\n",
		    newProb,
		    xmissionMatrix[newXmissionIndex[DAD]].prob[DAD + 1],
		    xmissionMatrix[newXmissionIndex[MOM]].prob[MOM + 1]);
#endif



	      /* we have completed one multilocus genotype for this child */
	      /* check whether we already have some information about this kid
	       * we should have if this kid is a connector to another nuclear
	       * family we have processed before */
	      if (pChild != pProband)
		{
		  if (pChild->pLikelihood[multiLocusIndex].touchedFlag == 1)
		    {
		      *(double *) pSum +=
			newProb *
			pChild->pLikelihood[multiLocusIndex].likelihood;
		    }
		  if (locusList->traitLocus >= 0)
		    {
		      *(double *) pSum +=
			newProb * pChild->pGenotyepe->penetrance;
		    }
		}
	      else
		{
		  /* penetrance if applicable will be figured into later */
		  *(double *) pSum += newProb;
		}
	    }
	}
    }				/* end of looping the genotype list for this locus */
  return 0;
}


/* Compute likelihood for parental multilocus genotypes pairs that are only different in phases 
 * Input: parental pairs for this nuclear family
 *        parental pairs with different phases are next to each other
 *        weight - genotype weights for the parental genotypes 
 *                 LE:
 *                   founder - phase doesn't matter
 *                   non-founder - phase will come to play
 *                 LD: 
 *                   phase matters for both founders and non-founders
 *        penetrance - is not an input as it can be different for different phases if we consider
 *                     imprinting effect
 *                     penetrance only applies to disease locus if it's included in the list 
*/
void
loop_phases (NuclearFamily * pNucFam, int locus, int multiLocusIndex[2],
	     int multiLocusPhase[2], void *dWeight[2])
{
  int multiLocusIndex2[2];
  int multiLocusPhase2[2];
  Person *pParent[2];
  int numGenotype[2];
  int i;
  int numPair;

  for (i = DAD; i <= MOM; i++)
    {
      pParent[i] = pNucFam->pParents[i];
      /* find the max number of possible genotypes for this parent */
      numGenotype[i] = pNucFam->pParents[i]->pSavedNumGenotype[origLocus];
      multiLocusIndex2[i] = multiLocusIndex[i] * numGenotype[i];
      if (pNucFam->hetFlag[locus][i] == 1)
	{
	  multiLocusPhase2[i] = multiLocusPhase[i] * 2;
	}
      else
	{
	  multiLocusPhase2[i] = multiLocusPhase[i];
	}
    }

  numPair = pNucFam->relatedPPairStart[locus] - 1;
  while ((numPair += 1) < pNucFam->pNumPhases[locus])
    {
      pPair = &pHaplo->ppParentalPair[locus][numPair];
      pHaplo->pParentalPairInd[locus] = numPair;
      pNucFam->phasePattern[locus][i] = pPair->phasePattern[i];
      multiLocusPhase[i] = multiLocusPhase2[i] + pPair->phasePattern[i];
      if (locus < locusList.numLocus - 1)
	{
	  multiLocusIndex[i] =
	    multiLocusIndex2[i] + pPair->pGenotype[i]->position;
	  loop_phases (pNucFam, locus + 1, multiLocusIndex, multiLocusPhase);
	}
      else
	{
	  calculateFlag = 0;
	  /* got a complete multilocus parental pair */
	  if(pProband != pParent[DAD] && pProband != pParent[MOM])
	    {
	      /* child is the proband */
	      foundFlag = 0;
	      for(i=DAD; i <= MOM; i++)
		{
		  if (pNucFam->phasePattern[pNucFam->firstHetLocus[i]][i] != 0)
		    {
		      /* first het locus has a reverse phase than the origninal 
		       * potentially we could benefit from directly using the likelihood calculated 
		       * with different phase
		       */
		      /* if this parent is a founder or a proband, then flip==original */
		      if (pParent[i]->pDad == NULL)
			{
			  multiLocusPhaseFlip[i] =
			    ~multiLocusPhase[i] & locusBits;
			  phase[i] = multiLocusPhaseFlip[i];
			  foundFlag = 1;
			}
		      else
			calculateFlag = 1;
		    }
		
		  else
		    {
		      /* no possible reverse pattern yet */
		      calculateFlag = 1;
		    }
		}
	      if(foundFlag == 1)
		{
		  ppPairMatrix[phase[DAD]][phase[MOM]].count++;
		}
	      else
		calculateFlag = 1;
	      
	    }
	  else 
	    {
	      /* one parent is proband */
	      spouse = 1;
	      if(pNucFam->phasePattern[pNucFam->firstHetLocus[spouse]][spouse] != 0)
		{
		  if(pParent[spouse]->pDad == NULL)
		    {
		      /* non-proband parent is a founder */
		      /* find the reverse pattern */
		      /* increase the count on the original to 2 */
		    }
		  else
		    calculateFlag = 1;
		}
	      if(pNucFam->phasePattern[pNucFam->firstHetLocus[proband]][proband] != 0)
		{
		  /* check whether spouse need to be flipped */
		  if(pNucFam->phasePattern[pNucFam->firstHetLocus[spouse]][spouse] != 0 && 
		     pParent[spouse]->pDad == NULL)
		    {
		      /* find the reverse pattern */
		    }
		  ppairMatrix[][] = ppairMatrix[original][original];
		}
	      
	
	  if (calculateFlag == 1)
	    {
	      likelihood = 1;
	      for (i = DAD; i <= MOM; i++)
		{
		  if (pProband[i] != pProband)
		    {
		      if (pParent[i]->pParent == NULL)
			{
			  /* this parent is a founder. the weight is just the multiplication of 
			     genotype weights at each locus under LE. The weight should have been passed 
			     in as an input */
			  if (modelOptions.analysisType ==
			      LINKAGE_EQUILIBRIUM)
			    {
			      newWeight[i] = *((double *) dWeight + i);
			    }
			  else
			    {
			      /* use haplotype frequency instead */
#ifndef NO_POlYNOMIAL
			      if (modelOptions.polynomial == TRUE)
				{

				  get_haplotype_freq (locus, i,
						      &freqPolynomial,
						      pHaplo);
				}
			      else
				{
				  get_haplotype_freq (locus, i, &freq,
						      pHaplo);
				  newWeight[i] = freq;
				}
#else
			      get_haplotype_freq (locus, i, &freq, pHaplo);
			      newWeight[i] = freq;
#endif
			    }
			  /* need to multiply the penetrance if disease locus is in */
			  if (locusList->traitLocus >= 0)
			    {
			      newWeight[i] *=
				pHaplo->ppParentalPair[locusList->
						       traitLocus][pHaplo->
								   pParentalPairInd
								   [locusList->
								    traitLocus]]->
				pGenotype[i]->penetrance;
			    }
			}
		      else
			{
			  /* this parent is not a founder. the weight should just be the likelihood
			     we have already calculated before (we must have, otherwise we can't even
			     process this nuclear family
			     Also the penetrance should have been included in the previous likelihood
			     calculation already
			   */
			  newWeight[i] =
			    pParent[i]->pLikelihood[multiLocusIndex[i]].
			    likelihood;
			}
		      likelihood *= newWeight[i];
		    }		/* parent is not a proband */
		  else
		    {
		      newWeight[i] = 1;
		    }
		}		/* loop over each parent */

	      /* now work on the children conditional on this parental pair */
	      childProduct = 1;
	      for (child = 0; child < pNucFam->numChildren; child++)
		{
		  xmissionIndex[DAD] = 0;
		  xmissionIndex[MOM] = 0;

		  sum = 0;
		  prob = 1;
		  childPenetrance = 1;
		  loop_child_multi_locus_genotype (pNucFam->
						   ppChildrenList[child],
						   pProband, pHaplo, child, 0,
						   0, &childPenetrance, &sum,
						   &prob, xmissionIndex,
						   chromosome);

		  childProduct *= sum;
		}
	      likelihood *= childProduct;
	      /* save it */
	      ppairMatrix[][] = likelihood;

	    }			/* fresh likelihood calculation */


	}			/* end of processing a complete multilocus parental pair */


    }				/* move on to next pair on this locus */

}



/* Nuclear family contains the following structures
   number of heterozygous loci for each parent 
   first heterozygous locus for each parent 
   list of het/homo flag for each locus for each parent 

   first related parental pair index at each locus 
   number of related parental pairs at each locus 
   current parental pair phase pattern 
*/


void
get_haplotype_freq (int locus, int parent, void *freqPtr,
		    ParentalPairSpace * pHaplo)
{
  int originalLocus1, originalLocus2;
  double *freqValue = (double *) freqPtr;
#ifndef NO_POLYNOMIAL
  Polynomial **freqPolynomial = (Polynomial **) freqPtr;
  char vName[100];
#endif
  ParentalPair *pPair;
  ParentalPair *pTempPair;
  Locus *pLocus = originalLocusList.ppLocusList[origLocus2];
  Locus *pLocusTemp;
  int k, l;
  LDLoci *pLDLoci;
  int alleleID1, alleleID2;
  AlleleSet *pAlleleSet1, *pAlleleSet2;
  double freq = 0;


  origLocus1 = locusList->pLocusIndex[locus - 1];
  origLocus2 = locusList->pLocusIndex[locus];
  pLocusTemp = originalLocusList.ppLocusList[origLocus1];
  /* find the parameter values for these two loci */
  pLDLoci = find_LD_loci (origLocus1, origLocus2);
  KASSERT (pLDLoci != NULL,
	   "Can't find LD parameter between loci %d,%d.\n",
	   origLocus1, origLocus2);
  /* now find the corresponding haplotype frequency : 2 haplotypes 
   * paternal haplotype & maternal haplotype */
  pPair = &pHaplo->ppParentalPair[locus][pHaplo->pParentalPairInd[locus]];
  pTempPair =
    &pHaplo->ppParentalPair[locus - 1][pHaplo->pParentalPairInd[locus - 1]];
  alleleID2 = pPair->pGenotype[i]->allele[parent];
  alleleID1 = pTempPair->pGenotype[i]->allele[parent];
  pAlleleSet1 = pLocusTemp->ppAlleleSetList[alleleID1 - 1];
  pAlleleSet2 = pLocus->ppAlleleSetList[alleleID2 - 1];
#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial == TRUE)
    {
      freqPolynomial = constantExp (0);
    }
  else
    freq = 0;
#else
  freq = 0;
#endif
  for (k = 0; k < pAlleleSet1->numAllele; k++)
    {
      for (l = 0; l < pAlleleSet2->numAllele; l++)
	{
	  allele1 = pAlleleSet1->pAlleles[k];
	  allele2 = pAlleleSet2->pAlleles[l];
#ifndef NO_POLYNOMIAL
	  if (modelOptions.polynomial == TRUE)
	    {
	      sprintf (vName, "ppHaploFreq[%d][%d]",
		       allele1 - 1, allele2 - 1);
	      *freqPolynomial =
		plusExp (2, 1.0, *freqPolynomial, 1.0,
			 variableExp (&pLDLoci->
				      ppHaploFreq
				      [allele1 -
				       1][allele2 - 1], NULL, 'D', vName), 1);
	    }
	  else
	    freq += pLDLoci->ppHaploFreq[allele1 - 1][allele2 - 1];
#else
	  freq += pLDLoci->ppHaploFreq[allele1 - 1][allele2 - 1];
#endif
	}
    }
#ifndef NO_POLYNOMIAL
  if (modelOptions.polynomial != TRUE)
    *freqValue = freq;
#else
  *freqValue = freq;
#endif
}
